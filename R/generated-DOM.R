# Generated by wiipoc/data-raw/generated.R: do not edit by hand

#' Accordion widget
#'
#' @export
jupyter.widget.Accordion <- R6::R6Class("jupyter.widget.Accordion", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param box_style Use a predefined styling for the box.
    #' @param children List of widget children
    #' @param selected_index The index of the selected page. This is either an integer selecting a particular sub-widget, or None to have no widgets selected.
    #' @param titles Titles of the pages
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Accordion' widget
    initialize = function(
      box_style = "",
      children = list(),
      selected_index = NULL,
      titles = list(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        box_style = self$check_state('box_style', box_style),
        children = self$check_state('children', children),
        selected_index = self$check_state('selected_index', selected_index),
        titles = self$check_state('titles', titles)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "AccordionModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "AccordionView",
        
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field box_style
    #' Use a predefined styling for the box.
    box_style = function(x) if(missing(x)) private$state_[['box_style']] else self$update(box_style = self$check_state('box_style', x)),
    
    #' @field children
    #' List of widget children
    children = function(x) if(missing(x)) private$state_[['children']] else self$update(children = self$check_state('children', x)),
    
    #' @field selected_index
    #' The index of the selected page. This is either an integer selecting a particular sub-widget, or None to have no widgets selected.
    selected_index = function(x) if(missing(x)) private$state_[['selected_index']] else self$update(selected_index = self$check_state('selected_index', x)),
    
    #' @field titles
    #' Titles of the pages
    titles = function(x) if(missing(x)) private$state_[['titles']] else self$update(titles = self$check_state('titles', x))
  )
)

#' Accordion widget
#'
#' @param box_style Use a predefined styling for the box.
#' @param children List of widget children
#' @param selected_index The index of the selected page. This is either an integer selecting a particular sub-widget, or None to have no widgets selected.
#' @param titles Titles of the pages
#' 
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Accordion <- function(
  box_style = "",
  children = list(),
  selected_index = NULL,
  titles = list(),
  ...,
  error_call = current_env()
){
  jupyter.widget.Accordion$new(
    box_style = box_style,
    children = children,
    selected_index = selected_index,
    titles = titles,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.Accordion", "box_style", unbox_one_of(c("success", "info", "warning", "danger"), allow_null = TRUE, allow_empty = TRUE))
})

#' Checkbox widget
#'
#' @export
jupyter.widget.Checkbox <- R6::R6Class("jupyter.widget.Checkbox", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes.
    #' @param indent Indent the control to align with other controls with a description.
    #' @param value Bool value
    #' @param style Must inherit from [jupyter.widget.CheckboxStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Checkbox' widget
    initialize = function(
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      indent = TRUE,
      value = FALSE,
      style = CheckboxStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        indent = self$check_state('indent', indent),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "CheckboxModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "CheckboxView",
        style = style, 
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes.
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field indent
    #' Indent the control to align with other controls with a description.
    indent = function(x) if(missing(x)) private$state_[['indent']] else self$update(indent = self$check_state('indent', x)),
    
    #' @field value
    #' Bool value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' Checkbox widget
#'
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes.
#' @param indent Indent the control to align with other controls with a description.
#' @param value Bool value
#' 
#' @param style Must inherit from [jupyter.widget.CheckboxStyle].
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Checkbox <- function(
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  indent = TRUE,
  value = FALSE,
  style = CheckboxStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.Checkbox$new(
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    indent = indent,
    value = value,
    style = style,
    ...,
    error_call = error_call
  )
}


#' ColorPicker widget
#'
#' @export
jupyter.widget.ColorPicker <- R6::R6Class("jupyter.widget.ColorPicker", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param concise Display short version with just a color selector.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes.
    #' @param value The color value.
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.ColorPicker' widget
    initialize = function(
      concise = FALSE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      value = "black",

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        concise = self$check_state('concise', concise),
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "ColorPickerModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "ColorPickerView",
        
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field concise
    #' Display short version with just a color selector.
    concise = function(x) if(missing(x)) private$state_[['concise']] else self$update(concise = self$check_state('concise', x)),
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes.
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field value
    #' The color value.
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' ColorPicker widget
#'
#' @param concise Display short version with just a color selector.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes.
#' @param value The color value.
#' 
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
ColorPicker <- function(
  concise = FALSE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  value = "black",
  ...,
  error_call = current_env()
){
  jupyter.widget.ColorPicker$new(
    concise = concise,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    value = value,
    ...,
    error_call = error_call
  )
}


#' ColorsInput widget
#'
#' @export
jupyter.widget.ColorsInput <- R6::R6Class("jupyter.widget.ColorsInput", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param allow_duplicates (undocumented)
    #' @param allowed_tags (undocumented)
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param placeholder (undocumented)
    #' @param value List of string tags
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.ColorsInput' widget
    initialize = function(
      allow_duplicates = TRUE,
      allowed_tags = list(),
      description = "",
      description_allow_html = FALSE,
      placeholder = "\U{200B}",
      value = list(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        allow_duplicates = self$check_state('allow_duplicates', allow_duplicates),
        allowed_tags = self$check_state('allowed_tags', allowed_tags),
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        placeholder = self$check_state('placeholder', placeholder),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "ColorsInputModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "ColorsInputView",
        
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field allow_duplicates
    #' 
    allow_duplicates = function(x) if(missing(x)) private$state_[['allow_duplicates']] else self$update(allow_duplicates = self$check_state('allow_duplicates', x)),
    
    #' @field allowed_tags
    #' 
    allowed_tags = function(x) if(missing(x)) private$state_[['allowed_tags']] else self$update(allowed_tags = self$check_state('allowed_tags', x)),
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field placeholder
    #' 
    placeholder = function(x) if(missing(x)) private$state_[['placeholder']] else self$update(placeholder = self$check_state('placeholder', x)),
    
    #' @field value
    #' List of string tags
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' ColorsInput widget
#'
#' @param allow_duplicates (undocumented)
#' @param allowed_tags (undocumented)
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param placeholder (undocumented)
#' @param value List of string tags
#' 
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
ColorsInput <- function(
  allow_duplicates = TRUE,
  allowed_tags = list(),
  description = "",
  description_allow_html = FALSE,
  placeholder = "\U{200B}",
  value = list(),
  ...,
  error_call = current_env()
){
  jupyter.widget.ColorsInput$new(
    allow_duplicates = allow_duplicates,
    allowed_tags = allowed_tags,
    description = description,
    description_allow_html = description_allow_html,
    placeholder = placeholder,
    value = value,
    ...,
    error_call = error_call
  )
}


#' Combobox widget
#'
#' @export
jupyter.widget.Combobox <- R6::R6Class("jupyter.widget.Combobox", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param ensure_option If set, ensure value is in options. Implies continuous_update=False.
    #' @param options Dropdown options for the combobox
    #' @param placeholder Placeholder text to display when nothing has been typed
    #' @param value String value
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Combobox' widget
    initialize = function(
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      ensure_option = FALSE,
      options = list(),
      placeholder = "\U{200B}",
      value = "",

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        continuous_update = self$check_state('continuous_update', continuous_update),
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        ensure_option = self$check_state('ensure_option', ensure_option),
        options = self$check_state('options', options),
        placeholder = self$check_state('placeholder', placeholder),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "ComboboxModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "ComboboxView",
        
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field continuous_update
    #' Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x)),
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field ensure_option
    #' If set, ensure value is in options. Implies continuous_update=False.
    ensure_option = function(x) if(missing(x)) private$state_[['ensure_option']] else self$update(ensure_option = self$check_state('ensure_option', x)),
    
    #' @field options
    #' Dropdown options for the combobox
    options = function(x) if(missing(x)) private$state_[['options']] else self$update(options = self$check_state('options', x)),
    
    #' @field placeholder
    #' Placeholder text to display when nothing has been typed
    placeholder = function(x) if(missing(x)) private$state_[['placeholder']] else self$update(placeholder = self$check_state('placeholder', x)),
    
    #' @field value
    #' String value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' Combobox widget
#'
#' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param ensure_option If set, ensure value is in options. Implies continuous_update=False.
#' @param options Dropdown options for the combobox
#' @param placeholder Placeholder text to display when nothing has been typed
#' @param value String value
#' 
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Combobox <- function(
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  ensure_option = FALSE,
  options = list(),
  placeholder = "\U{200B}",
  value = "",
  ...,
  error_call = current_env()
){
  jupyter.widget.Combobox$new(
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    ensure_option = ensure_option,
    options = options,
    placeholder = placeholder,
    value = value,
    ...,
    error_call = error_call
  )
}


#' DatePicker widget
#'
#' @export
jupyter.widget.DatePicker <- R6::R6Class("jupyter.widget.DatePicker", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes.
    #' @param max (undocumented)
    #' @param min (undocumented)
    #' @param step The date step to use for the picker, in days, or "any".
    #' @param value (undocumented)
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.DatePicker' widget
    initialize = function(
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      max = NULL,
      min = NULL,
      step = 1L,
      value = NULL,

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        max = self$check_state('max', max),
        min = self$check_state('min', min),
        step = self$check_state('step', step),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "DatePickerModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "DatePickerView",
        
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes.
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field max
    #' 
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x)),
    
    #' @field min
    #' 
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x)),
    
    #' @field step
    #' The date step to use for the picker, in days, or "any".
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x)),
    
    #' @field value
    #' 
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' DatePicker widget
#'
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes.
#' @param max (undocumented)
#' @param min (undocumented)
#' @param step The date step to use for the picker, in days, or "any".
#' @param value (undocumented)
#' 
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
DatePicker <- function(
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  max = NULL,
  min = NULL,
  step = 1L,
  value = NULL,
  ...,
  error_call = current_env()
){
  jupyter.widget.DatePicker$new(
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    max = max,
    min = min,
    step = step,
    value = value,
    ...,
    error_call = error_call
  )
}


#' Datetime widget
#'
#' @export
jupyter.widget.Datetime <- R6::R6Class("jupyter.widget.Datetime", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes.
    #' @param max (undocumented)
    #' @param min (undocumented)
    #' @param value (undocumented)
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Datetime' widget
    initialize = function(
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      max = NULL,
      min = NULL,
      value = NULL,

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        max = self$check_state('max', max),
        min = self$check_state('min', min),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "DatetimeModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "DatetimeView",
        
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes.
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field max
    #' 
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x)),
    
    #' @field min
    #' 
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x)),
    
    #' @field value
    #' 
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' Datetime widget
#'
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes.
#' @param max (undocumented)
#' @param min (undocumented)
#' @param value (undocumented)
#' 
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Datetime <- function(
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  max = NULL,
  min = NULL,
  value = NULL,
  ...,
  error_call = current_env()
){
  jupyter.widget.Datetime$new(
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    max = max,
    min = min,
    value = value,
    ...,
    error_call = error_call
  )
}


#' NaiveDatetime widget
#'
#' @export
jupyter.widget.NaiveDatetime <- R6::R6Class("jupyter.widget.NaiveDatetime", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes.
    #' @param max (undocumented)
    #' @param min (undocumented)
    #' @param value (undocumented)
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.NaiveDatetime' widget
    initialize = function(
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      max = NULL,
      min = NULL,
      value = NULL,

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        max = self$check_state('max', max),
        min = self$check_state('min', min),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "NaiveDatetimeModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "DatetimeView",
        
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes.
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field max
    #' 
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x)),
    
    #' @field min
    #' 
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x)),
    
    #' @field value
    #' 
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' NaiveDatetime widget
#'
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes.
#' @param max (undocumented)
#' @param min (undocumented)
#' @param value (undocumented)
#' 
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
NaiveDatetime <- function(
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  max = NULL,
  min = NULL,
  value = NULL,
  ...,
  error_call = current_env()
){
  jupyter.widget.NaiveDatetime$new(
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    max = max,
    min = min,
    value = value,
    ...,
    error_call = error_call
  )
}


#' IntSlider widget
#'
#' @export
jupyter.widget.IntSlider <- R6::R6Class("jupyter.widget.IntSlider", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param behavior Slider dragging behavior.
    #' @param continuous_update Update the value of the widget as the user is holding the slider.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param max Max value
    #' @param min Min value
    #' @param orientation Vertical or horizontal.
    #' @param readout Display the current value of the slider next to it.
    #' @param readout_format Format for the readout
    #' @param step Minimum step to increment the value
    #' @param value Int value
    #' @param style Must inherit from [jupyter.widget.SliderStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.IntSlider' widget
    initialize = function(
      behavior = "drag-tap",
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      max = 100L,
      min = 0L,
      orientation = "horizontal",
      readout = TRUE,
      readout_format = "d",
      step = 1L,
      value = 0L,
      style = SliderStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        behavior = self$check_state('behavior', behavior),
        continuous_update = self$check_state('continuous_update', continuous_update),
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        max = self$check_state('max', max),
        min = self$check_state('min', min),
        orientation = self$check_state('orientation', orientation),
        readout = self$check_state('readout', readout),
        readout_format = self$check_state('readout_format', readout_format),
        step = self$check_state('step', step),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "IntSliderModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "IntSliderView",
        style = style, 
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field behavior
    #' Slider dragging behavior.
    behavior = function(x) if(missing(x)) private$state_[['behavior']] else self$update(behavior = self$check_state('behavior', x)),
    
    #' @field continuous_update
    #' Update the value of the widget as the user is holding the slider.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x)),
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field max
    #' Max value
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x)),
    
    #' @field min
    #' Min value
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x)),
    
    #' @field orientation
    #' Vertical or horizontal.
    orientation = function(x) if(missing(x)) private$state_[['orientation']] else self$update(orientation = self$check_state('orientation', x)),
    
    #' @field readout
    #' Display the current value of the slider next to it.
    readout = function(x) if(missing(x)) private$state_[['readout']] else self$update(readout = self$check_state('readout', x)),
    
    #' @field readout_format
    #' Format for the readout
    readout_format = function(x) if(missing(x)) private$state_[['readout_format']] else self$update(readout_format = self$check_state('readout_format', x)),
    
    #' @field step
    #' Minimum step to increment the value
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x)),
    
    #' @field value
    #' Int value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' IntSlider widget
#'
#' @param behavior Slider dragging behavior.
#' @param continuous_update Update the value of the widget as the user is holding the slider.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param max Max value
#' @param min Min value
#' @param orientation Vertical or horizontal.
#' @param readout Display the current value of the slider next to it.
#' @param readout_format Format for the readout
#' @param step Minimum step to increment the value
#' @param value Int value
#' 
#' @param style Must inherit from [jupyter.widget.SliderStyle].
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
IntSlider <- function(
  behavior = "drag-tap",
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  max = 100L,
  min = 0L,
  orientation = "horizontal",
  readout = TRUE,
  readout_format = "d",
  step = 1L,
  value = 0L,
  style = SliderStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.IntSlider$new(
    behavior = behavior,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    max = max,
    min = min,
    orientation = orientation,
    readout = readout,
    readout_format = readout_format,
    step = step,
    value = value,
    style = style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.IntSlider", "behavior", unbox_one_of(c("drag-tap", "drag-snap", "tap", "drag", "snap"), allow_null = FALSE, allow_empty = FALSE))
  set_widget_state_check("jupyter.widget.IntSlider", "orientation", unbox_one_of(c("horizontal", "vertical"), allow_null = FALSE, allow_empty = FALSE))
})

#' FloatSlider widget
#'
#' @export
jupyter.widget.FloatSlider <- R6::R6Class("jupyter.widget.FloatSlider", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param behavior Slider dragging behavior.
    #' @param continuous_update Update the value of the widget as the user is holding the slider.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param max Max value
    #' @param min Min value
    #' @param orientation Vertical or horizontal.
    #' @param readout Display the current value of the slider next to it.
    #' @param readout_format Format for the readout
    #' @param step Minimum step to increment the value
    #' @param value Float value
    #' @param style Must inherit from [jupyter.widget.SliderStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.FloatSlider' widget
    initialize = function(
      behavior = "drag-tap",
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      max = 100,
      min = 0,
      orientation = "horizontal",
      readout = TRUE,
      readout_format = ".2f",
      step = 0.1,
      value = 0,
      style = SliderStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        behavior = self$check_state('behavior', behavior),
        continuous_update = self$check_state('continuous_update', continuous_update),
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        max = self$check_state('max', max),
        min = self$check_state('min', min),
        orientation = self$check_state('orientation', orientation),
        readout = self$check_state('readout', readout),
        readout_format = self$check_state('readout_format', readout_format),
        step = self$check_state('step', step),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "FloatSliderModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "FloatSliderView",
        style = style, 
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field behavior
    #' Slider dragging behavior.
    behavior = function(x) if(missing(x)) private$state_[['behavior']] else self$update(behavior = self$check_state('behavior', x)),
    
    #' @field continuous_update
    #' Update the value of the widget as the user is holding the slider.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x)),
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field max
    #' Max value
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x)),
    
    #' @field min
    #' Min value
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x)),
    
    #' @field orientation
    #' Vertical or horizontal.
    orientation = function(x) if(missing(x)) private$state_[['orientation']] else self$update(orientation = self$check_state('orientation', x)),
    
    #' @field readout
    #' Display the current value of the slider next to it.
    readout = function(x) if(missing(x)) private$state_[['readout']] else self$update(readout = self$check_state('readout', x)),
    
    #' @field readout_format
    #' Format for the readout
    readout_format = function(x) if(missing(x)) private$state_[['readout_format']] else self$update(readout_format = self$check_state('readout_format', x)),
    
    #' @field step
    #' Minimum step to increment the value
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x)),
    
    #' @field value
    #' Float value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' FloatSlider widget
#'
#' @param behavior Slider dragging behavior.
#' @param continuous_update Update the value of the widget as the user is holding the slider.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param max Max value
#' @param min Min value
#' @param orientation Vertical or horizontal.
#' @param readout Display the current value of the slider next to it.
#' @param readout_format Format for the readout
#' @param step Minimum step to increment the value
#' @param value Float value
#' 
#' @param style Must inherit from [jupyter.widget.SliderStyle].
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
FloatSlider <- function(
  behavior = "drag-tap",
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  max = 100,
  min = 0,
  orientation = "horizontal",
  readout = TRUE,
  readout_format = ".2f",
  step = 0.1,
  value = 0,
  style = SliderStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.FloatSlider$new(
    behavior = behavior,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    max = max,
    min = min,
    orientation = orientation,
    readout = readout,
    readout_format = readout_format,
    step = step,
    value = value,
    style = style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.FloatSlider", "behavior", unbox_one_of(c("drag-tap", "drag-snap", "tap", "drag", "snap"), allow_null = FALSE, allow_empty = FALSE))
  set_widget_state_check("jupyter.widget.FloatSlider", "orientation", unbox_one_of(c("horizontal", "vertical"), allow_null = FALSE, allow_empty = FALSE))
})

#' FloatLogSlider widget
#'
#' @export
jupyter.widget.FloatLogSlider <- R6::R6Class("jupyter.widget.FloatLogSlider", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param base Base for the logarithm
    #' @param behavior Slider dragging behavior.
    #' @param continuous_update Update the value of the widget as the user is holding the slider.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param max Max value for the exponent
    #' @param min Min value for the exponent
    #' @param orientation Vertical or horizontal.
    #' @param readout Display the current value of the slider next to it.
    #' @param readout_format Format for the readout
    #' @param step Minimum step in the exponent to increment the value
    #' @param value Float value
    #' @param style Must inherit from [jupyter.widget.SliderStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.FloatLogSlider' widget
    initialize = function(
      base = 10,
      behavior = "drag-tap",
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      max = 4,
      min = 0,
      orientation = "horizontal",
      readout = TRUE,
      readout_format = ".3g",
      step = 0.1,
      value = 1,
      style = SliderStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        base = self$check_state('base', base),
        behavior = self$check_state('behavior', behavior),
        continuous_update = self$check_state('continuous_update', continuous_update),
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        max = self$check_state('max', max),
        min = self$check_state('min', min),
        orientation = self$check_state('orientation', orientation),
        readout = self$check_state('readout', readout),
        readout_format = self$check_state('readout_format', readout_format),
        step = self$check_state('step', step),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "FloatLogSliderModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "FloatLogSliderView",
        style = style, 
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field base
    #' Base for the logarithm
    base = function(x) if(missing(x)) private$state_[['base']] else self$update(base = self$check_state('base', x)),
    
    #' @field behavior
    #' Slider dragging behavior.
    behavior = function(x) if(missing(x)) private$state_[['behavior']] else self$update(behavior = self$check_state('behavior', x)),
    
    #' @field continuous_update
    #' Update the value of the widget as the user is holding the slider.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x)),
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field max
    #' Max value for the exponent
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x)),
    
    #' @field min
    #' Min value for the exponent
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x)),
    
    #' @field orientation
    #' Vertical or horizontal.
    orientation = function(x) if(missing(x)) private$state_[['orientation']] else self$update(orientation = self$check_state('orientation', x)),
    
    #' @field readout
    #' Display the current value of the slider next to it.
    readout = function(x) if(missing(x)) private$state_[['readout']] else self$update(readout = self$check_state('readout', x)),
    
    #' @field readout_format
    #' Format for the readout
    readout_format = function(x) if(missing(x)) private$state_[['readout_format']] else self$update(readout_format = self$check_state('readout_format', x)),
    
    #' @field step
    #' Minimum step in the exponent to increment the value
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x)),
    
    #' @field value
    #' Float value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' FloatLogSlider widget
#'
#' @param base Base for the logarithm
#' @param behavior Slider dragging behavior.
#' @param continuous_update Update the value of the widget as the user is holding the slider.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param max Max value for the exponent
#' @param min Min value for the exponent
#' @param orientation Vertical or horizontal.
#' @param readout Display the current value of the slider next to it.
#' @param readout_format Format for the readout
#' @param step Minimum step in the exponent to increment the value
#' @param value Float value
#' 
#' @param style Must inherit from [jupyter.widget.SliderStyle].
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
FloatLogSlider <- function(
  base = 10,
  behavior = "drag-tap",
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  max = 4,
  min = 0,
  orientation = "horizontal",
  readout = TRUE,
  readout_format = ".3g",
  step = 0.1,
  value = 1,
  style = SliderStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.FloatLogSlider$new(
    base = base,
    behavior = behavior,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    max = max,
    min = min,
    orientation = orientation,
    readout = readout,
    readout_format = readout_format,
    step = step,
    value = value,
    style = style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.FloatLogSlider", "behavior", unbox_one_of(c("drag-tap", "drag-snap", "tap", "drag", "snap"), allow_null = FALSE, allow_empty = FALSE))
  set_widget_state_check("jupyter.widget.FloatLogSlider", "orientation", unbox_one_of(c("horizontal", "vertical"), allow_null = FALSE, allow_empty = FALSE))
})

#' FloatRangeSlider widget
#'
#' @export
jupyter.widget.FloatRangeSlider <- R6::R6Class("jupyter.widget.FloatRangeSlider", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param behavior Slider dragging behavior.
    #' @param continuous_update Update the value of the widget as the user is sliding the slider.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param max Max value
    #' @param min Min value
    #' @param orientation Vertical or horizontal.
    #' @param readout Display the current value of the slider next to it.
    #' @param readout_format Format for the readout
    #' @param step Minimum step to increment the value
    #' @param value Tuple of (lower, upper) bounds
    #' @param style Must inherit from [jupyter.widget.SliderStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.FloatRangeSlider' widget
    initialize = function(
      behavior = "drag-tap",
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      max = 100,
      min = 0,
      orientation = "horizontal",
      readout = TRUE,
      readout_format = ".2f",
      step = 0.1,
      value = list(0, 1),
      style = SliderStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        behavior = self$check_state('behavior', behavior),
        continuous_update = self$check_state('continuous_update', continuous_update),
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        max = self$check_state('max', max),
        min = self$check_state('min', min),
        orientation = self$check_state('orientation', orientation),
        readout = self$check_state('readout', readout),
        readout_format = self$check_state('readout_format', readout_format),
        step = self$check_state('step', step),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "FloatRangeSliderModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "FloatRangeSliderView",
        style = style, 
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field behavior
    #' Slider dragging behavior.
    behavior = function(x) if(missing(x)) private$state_[['behavior']] else self$update(behavior = self$check_state('behavior', x)),
    
    #' @field continuous_update
    #' Update the value of the widget as the user is sliding the slider.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x)),
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field max
    #' Max value
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x)),
    
    #' @field min
    #' Min value
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x)),
    
    #' @field orientation
    #' Vertical or horizontal.
    orientation = function(x) if(missing(x)) private$state_[['orientation']] else self$update(orientation = self$check_state('orientation', x)),
    
    #' @field readout
    #' Display the current value of the slider next to it.
    readout = function(x) if(missing(x)) private$state_[['readout']] else self$update(readout = self$check_state('readout', x)),
    
    #' @field readout_format
    #' Format for the readout
    readout_format = function(x) if(missing(x)) private$state_[['readout_format']] else self$update(readout_format = self$check_state('readout_format', x)),
    
    #' @field step
    #' Minimum step to increment the value
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x)),
    
    #' @field value
    #' Tuple of (lower, upper) bounds
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' FloatRangeSlider widget
#'
#' @param behavior Slider dragging behavior.
#' @param continuous_update Update the value of the widget as the user is sliding the slider.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param max Max value
#' @param min Min value
#' @param orientation Vertical or horizontal.
#' @param readout Display the current value of the slider next to it.
#' @param readout_format Format for the readout
#' @param step Minimum step to increment the value
#' @param value Tuple of (lower, upper) bounds
#' 
#' @param style Must inherit from [jupyter.widget.SliderStyle].
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
FloatRangeSlider <- function(
  behavior = "drag-tap",
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  max = 100,
  min = 0,
  orientation = "horizontal",
  readout = TRUE,
  readout_format = ".2f",
  step = 0.1,
  value = list(0, 1),
  style = SliderStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.FloatRangeSlider$new(
    behavior = behavior,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    max = max,
    min = min,
    orientation = orientation,
    readout = readout,
    readout_format = readout_format,
    step = step,
    value = value,
    style = style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.FloatRangeSlider", "behavior", unbox_one_of(c("drag-tap", "drag-snap", "tap", "drag", "snap"), allow_null = FALSE, allow_empty = FALSE))
  set_widget_state_check("jupyter.widget.FloatRangeSlider", "orientation", unbox_one_of(c("horizontal", "vertical"), allow_null = FALSE, allow_empty = FALSE))
})

#' IntRangeSlider widget
#'
#' @export
jupyter.widget.IntRangeSlider <- R6::R6Class("jupyter.widget.IntRangeSlider", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param behavior Slider dragging behavior.
    #' @param continuous_update Update the value of the widget as the user is sliding the slider.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param max Max value
    #' @param min Min value
    #' @param orientation Vertical or horizontal.
    #' @param readout Display the current value of the slider next to it.
    #' @param readout_format Format for the readout
    #' @param step Minimum step that the value can take
    #' @param value Tuple of (lower, upper) bounds
    #' @param style Must inherit from [jupyter.widget.SliderStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.IntRangeSlider' widget
    initialize = function(
      behavior = "drag-tap",
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      max = 100L,
      min = 0L,
      orientation = "horizontal",
      readout = TRUE,
      readout_format = "d",
      step = 1L,
      value = list(0L, 1L),
      style = SliderStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        behavior = self$check_state('behavior', behavior),
        continuous_update = self$check_state('continuous_update', continuous_update),
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        max = self$check_state('max', max),
        min = self$check_state('min', min),
        orientation = self$check_state('orientation', orientation),
        readout = self$check_state('readout', readout),
        readout_format = self$check_state('readout_format', readout_format),
        step = self$check_state('step', step),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "IntRangeSliderModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "IntRangeSliderView",
        style = style, 
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field behavior
    #' Slider dragging behavior.
    behavior = function(x) if(missing(x)) private$state_[['behavior']] else self$update(behavior = self$check_state('behavior', x)),
    
    #' @field continuous_update
    #' Update the value of the widget as the user is sliding the slider.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x)),
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field max
    #' Max value
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x)),
    
    #' @field min
    #' Min value
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x)),
    
    #' @field orientation
    #' Vertical or horizontal.
    orientation = function(x) if(missing(x)) private$state_[['orientation']] else self$update(orientation = self$check_state('orientation', x)),
    
    #' @field readout
    #' Display the current value of the slider next to it.
    readout = function(x) if(missing(x)) private$state_[['readout']] else self$update(readout = self$check_state('readout', x)),
    
    #' @field readout_format
    #' Format for the readout
    readout_format = function(x) if(missing(x)) private$state_[['readout_format']] else self$update(readout_format = self$check_state('readout_format', x)),
    
    #' @field step
    #' Minimum step that the value can take
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x)),
    
    #' @field value
    #' Tuple of (lower, upper) bounds
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' IntRangeSlider widget
#'
#' @param behavior Slider dragging behavior.
#' @param continuous_update Update the value of the widget as the user is sliding the slider.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param max Max value
#' @param min Min value
#' @param orientation Vertical or horizontal.
#' @param readout Display the current value of the slider next to it.
#' @param readout_format Format for the readout
#' @param step Minimum step that the value can take
#' @param value Tuple of (lower, upper) bounds
#' 
#' @param style Must inherit from [jupyter.widget.SliderStyle].
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
IntRangeSlider <- function(
  behavior = "drag-tap",
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  max = 100L,
  min = 0L,
  orientation = "horizontal",
  readout = TRUE,
  readout_format = "d",
  step = 1L,
  value = list(0L, 1L),
  style = SliderStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.IntRangeSlider$new(
    behavior = behavior,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    max = max,
    min = min,
    orientation = orientation,
    readout = readout,
    readout_format = readout_format,
    step = step,
    value = value,
    style = style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.IntRangeSlider", "behavior", unbox_one_of(c("drag-tap", "drag-snap", "tap", "drag", "snap"), allow_null = FALSE, allow_empty = FALSE))
  set_widget_state_check("jupyter.widget.IntRangeSlider", "orientation", unbox_one_of(c("horizontal", "vertical"), allow_null = FALSE, allow_empty = FALSE))
})

#' Text widget
#'
#' @export
jupyter.widget.Text <- R6::R6Class("jupyter.widget.Text", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param placeholder Placeholder text to display when nothing has been typed
    #' @param value String value
    #' @param style Must inherit from [jupyter.widget.TextStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Text' widget
    initialize = function(
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      placeholder = "\U{200B}",
      value = "",
      style = TextStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        continuous_update = self$check_state('continuous_update', continuous_update),
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        placeholder = self$check_state('placeholder', placeholder),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "TextModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "TextView",
        style = style, 
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field continuous_update
    #' Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x)),
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field placeholder
    #' Placeholder text to display when nothing has been typed
    placeholder = function(x) if(missing(x)) private$state_[['placeholder']] else self$update(placeholder = self$check_state('placeholder', x)),
    
    #' @field value
    #' String value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' Text widget
#'
#' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param placeholder Placeholder text to display when nothing has been typed
#' @param value String value
#' 
#' @param style Must inherit from [jupyter.widget.TextStyle].
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Text <- function(
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  placeholder = "\U{200B}",
  value = "",
  style = TextStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.Text$new(
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    placeholder = placeholder,
    value = value,
    style = style,
    ...,
    error_call = error_call
  )
}


#' IntText widget
#'
#' @export
jupyter.widget.IntText <- R6::R6Class("jupyter.widget.IntText", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param step Minimum step to increment the value
    #' @param value Int value
    #' @param style Must inherit from [jupyter.widget.TextStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.IntText' widget
    initialize = function(
      continuous_update = FALSE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      step = 1L,
      value = 0L,
      style = TextStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        continuous_update = self$check_state('continuous_update', continuous_update),
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        step = self$check_state('step', step),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "IntTextModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "IntTextView",
        style = style, 
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field continuous_update
    #' Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x)),
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field step
    #' Minimum step to increment the value
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x)),
    
    #' @field value
    #' Int value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' IntText widget
#'
#' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param step Minimum step to increment the value
#' @param value Int value
#' 
#' @param style Must inherit from [jupyter.widget.TextStyle].
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
IntText <- function(
  continuous_update = FALSE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  step = 1L,
  value = 0L,
  style = TextStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.IntText$new(
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    step = step,
    value = value,
    style = style,
    ...,
    error_call = error_call
  )
}


#' FloatText widget
#'
#' @export
jupyter.widget.FloatText <- R6::R6Class("jupyter.widget.FloatText", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param step Minimum step to increment the value
    #' @param value Float value
    #' @param style Must inherit from [jupyter.widget.TextStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.FloatText' widget
    initialize = function(
      continuous_update = FALSE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      step = NULL,
      value = 0,
      style = TextStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        continuous_update = self$check_state('continuous_update', continuous_update),
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        step = self$check_state('step', step),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "FloatTextModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "FloatTextView",
        style = style, 
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field continuous_update
    #' Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x)),
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field step
    #' Minimum step to increment the value
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x)),
    
    #' @field value
    #' Float value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' FloatText widget
#'
#' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param step Minimum step to increment the value
#' @param value Float value
#' 
#' @param style Must inherit from [jupyter.widget.TextStyle].
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
FloatText <- function(
  continuous_update = FALSE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  step = NULL,
  value = 0,
  style = TextStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.FloatText$new(
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    step = step,
    value = value,
    style = style,
    ...,
    error_call = error_call
  )
}


#' BoundedIntText widget
#'
#' @export
jupyter.widget.BoundedIntText <- R6::R6Class("jupyter.widget.BoundedIntText", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param max Max value
    #' @param min Min value
    #' @param step Minimum step to increment the value
    #' @param value Int value
    #' @param style Must inherit from [jupyter.widget.TextStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.BoundedIntText' widget
    initialize = function(
      continuous_update = FALSE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      max = 100L,
      min = 0L,
      step = 1L,
      value = 0L,
      style = TextStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        continuous_update = self$check_state('continuous_update', continuous_update),
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        max = self$check_state('max', max),
        min = self$check_state('min', min),
        step = self$check_state('step', step),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "BoundedIntTextModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "IntTextView",
        style = style, 
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field continuous_update
    #' Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x)),
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field max
    #' Max value
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x)),
    
    #' @field min
    #' Min value
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x)),
    
    #' @field step
    #' Minimum step to increment the value
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x)),
    
    #' @field value
    #' Int value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' BoundedIntText widget
#'
#' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param max Max value
#' @param min Min value
#' @param step Minimum step to increment the value
#' @param value Int value
#' 
#' @param style Must inherit from [jupyter.widget.TextStyle].
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
BoundedIntText <- function(
  continuous_update = FALSE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  max = 100L,
  min = 0L,
  step = 1L,
  value = 0L,
  style = TextStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.BoundedIntText$new(
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    max = max,
    min = min,
    step = step,
    value = value,
    style = style,
    ...,
    error_call = error_call
  )
}


#' BoundedFloatText widget
#'
#' @export
jupyter.widget.BoundedFloatText <- R6::R6Class("jupyter.widget.BoundedFloatText", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param max Max value
    #' @param min Min value
    #' @param step Minimum step to increment the value
    #' @param value Float value
    #' @param style Must inherit from [jupyter.widget.TextStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.BoundedFloatText' widget
    initialize = function(
      continuous_update = FALSE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      max = 100,
      min = 0,
      step = NULL,
      value = 0,
      style = TextStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        continuous_update = self$check_state('continuous_update', continuous_update),
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        max = self$check_state('max', max),
        min = self$check_state('min', min),
        step = self$check_state('step', step),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "BoundedFloatTextModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "FloatTextView",
        style = style, 
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field continuous_update
    #' Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x)),
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field max
    #' Max value
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x)),
    
    #' @field min
    #' Min value
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x)),
    
    #' @field step
    #' Minimum step to increment the value
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x)),
    
    #' @field value
    #' Float value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' BoundedFloatText widget
#'
#' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param max Max value
#' @param min Min value
#' @param step Minimum step to increment the value
#' @param value Float value
#' 
#' @param style Must inherit from [jupyter.widget.TextStyle].
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
BoundedFloatText <- function(
  continuous_update = FALSE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  max = 100,
  min = 0,
  step = NULL,
  value = 0,
  style = TextStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.BoundedFloatText$new(
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    max = max,
    min = min,
    step = step,
    value = value,
    style = style,
    ...,
    error_call = error_call
  )
}


#' HTML widget
#'
#' @export
jupyter.widget.HTML <- R6::R6Class("jupyter.widget.HTML", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param placeholder Placeholder text to display when nothing has been typed
    #' @param value String value
    #' @param style Must inherit from [jupyter.widget.HTMLStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.HTML' widget
    initialize = function(
      description = "",
      description_allow_html = FALSE,
      placeholder = "\U{200B}",
      value = "",
      style = HTMLStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        placeholder = self$check_state('placeholder', placeholder),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "HTMLModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "HTMLView",
        style = style, 
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field placeholder
    #' Placeholder text to display when nothing has been typed
    placeholder = function(x) if(missing(x)) private$state_[['placeholder']] else self$update(placeholder = self$check_state('placeholder', x)),
    
    #' @field value
    #' String value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' HTML widget
#'
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param placeholder Placeholder text to display when nothing has been typed
#' @param value String value
#' 
#' @param style Must inherit from [jupyter.widget.HTMLStyle].
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
HTML <- function(
  description = "",
  description_allow_html = FALSE,
  placeholder = "\U{200B}",
  value = "",
  style = HTMLStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.HTML$new(
    description = description,
    description_allow_html = description_allow_html,
    placeholder = placeholder,
    value = value,
    style = style,
    ...,
    error_call = error_call
  )
}


#' HTMLMath widget
#'
#' @export
jupyter.widget.HTMLMath <- R6::R6Class("jupyter.widget.HTMLMath", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param placeholder Placeholder text to display when nothing has been typed
    #' @param value String value
    #' @param style Must inherit from [jupyter.widget.HTMLMathStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.HTMLMath' widget
    initialize = function(
      description = "",
      description_allow_html = FALSE,
      placeholder = "\U{200B}",
      value = "",
      style = HTMLMathStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        placeholder = self$check_state('placeholder', placeholder),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "HTMLMathModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "HTMLMathView",
        style = style, 
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field placeholder
    #' Placeholder text to display when nothing has been typed
    placeholder = function(x) if(missing(x)) private$state_[['placeholder']] else self$update(placeholder = self$check_state('placeholder', x)),
    
    #' @field value
    #' String value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' HTMLMath widget
#'
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param placeholder Placeholder text to display when nothing has been typed
#' @param value String value
#' 
#' @param style Must inherit from [jupyter.widget.HTMLMathStyle].
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
HTMLMath <- function(
  description = "",
  description_allow_html = FALSE,
  placeholder = "\U{200B}",
  value = "",
  style = HTMLMathStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.HTMLMath$new(
    description = description,
    description_allow_html = description_allow_html,
    placeholder = placeholder,
    value = value,
    style = style,
    ...,
    error_call = error_call
  )
}


#' ToggleButton widget
#'
#' @export
jupyter.widget.ToggleButton <- R6::R6Class("jupyter.widget.ToggleButton", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param button_style Use a predefined styling for the button.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes.
    #' @param icon Font-awesome icon.
    #' @param value Bool value
    #' @param style Must inherit from [jupyter.widget.ToggleButtonStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.ToggleButton' widget
    initialize = function(
      button_style = "",
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      icon = "",
      value = FALSE,
      style = ToggleButtonStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        button_style = self$check_state('button_style', button_style),
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        icon = self$check_state('icon', icon),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "ToggleButtonModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "ToggleButtonView",
        style = style, 
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field button_style
    #' Use a predefined styling for the button.
    button_style = function(x) if(missing(x)) private$state_[['button_style']] else self$update(button_style = self$check_state('button_style', x)),
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes.
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field icon
    #' Font-awesome icon.
    icon = function(x) if(missing(x)) private$state_[['icon']] else self$update(icon = self$check_state('icon', x)),
    
    #' @field value
    #' Bool value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' ToggleButton widget
#'
#' @param button_style Use a predefined styling for the button.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes.
#' @param icon Font-awesome icon.
#' @param value Bool value
#' 
#' @param style Must inherit from [jupyter.widget.ToggleButtonStyle].
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
ToggleButton <- function(
  button_style = "",
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  icon = "",
  value = FALSE,
  style = ToggleButtonStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.ToggleButton$new(
    button_style = button_style,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    icon = icon,
    value = value,
    style = style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.ToggleButton", "button_style", unbox_one_of(c("primary", "success", "info", "warning", "danger"), allow_null = TRUE, allow_empty = TRUE))
})

#' Label widget
#'
#' @export
jupyter.widget.Label <- R6::R6Class("jupyter.widget.Label", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param placeholder Placeholder text to display when nothing has been typed
    #' @param value String value
    #' @param style Must inherit from [jupyter.widget.LabelStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Label' widget
    initialize = function(
      description = "",
      description_allow_html = FALSE,
      placeholder = "\U{200B}",
      value = "",
      style = LabelStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        placeholder = self$check_state('placeholder', placeholder),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "LabelModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "LabelView",
        style = style, 
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field placeholder
    #' Placeholder text to display when nothing has been typed
    placeholder = function(x) if(missing(x)) private$state_[['placeholder']] else self$update(placeholder = self$check_state('placeholder', x)),
    
    #' @field value
    #' String value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' Label widget
#'
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param placeholder Placeholder text to display when nothing has been typed
#' @param value String value
#' 
#' @param style Must inherit from [jupyter.widget.LabelStyle].
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Label <- function(
  description = "",
  description_allow_html = FALSE,
  placeholder = "\U{200B}",
  value = "",
  style = LabelStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.Label$new(
    description = description,
    description_allow_html = description_allow_html,
    placeholder = placeholder,
    value = value,
    style = style,
    ...,
    error_call = error_call
  )
}


#' IntProgress widget
#'
#' @export
jupyter.widget.IntProgress <- R6::R6Class("jupyter.widget.IntProgress", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param bar_style Use a predefined styling for the progress bar.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param max Max value
    #' @param min Min value
    #' @param orientation Vertical or horizontal.
    #' @param value Int value
    #' @param style Must inherit from [jupyter.widget.ProgressStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.IntProgress' widget
    initialize = function(
      bar_style = "",
      description = "",
      description_allow_html = FALSE,
      max = 100L,
      min = 0L,
      orientation = "horizontal",
      value = 0L,
      style = ProgressStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        bar_style = self$check_state('bar_style', bar_style),
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        max = self$check_state('max', max),
        min = self$check_state('min', min),
        orientation = self$check_state('orientation', orientation),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "IntProgressModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "ProgressView",
        style = style, 
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field bar_style
    #' Use a predefined styling for the progress bar.
    bar_style = function(x) if(missing(x)) private$state_[['bar_style']] else self$update(bar_style = self$check_state('bar_style', x)),
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field max
    #' Max value
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x)),
    
    #' @field min
    #' Min value
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x)),
    
    #' @field orientation
    #' Vertical or horizontal.
    orientation = function(x) if(missing(x)) private$state_[['orientation']] else self$update(orientation = self$check_state('orientation', x)),
    
    #' @field value
    #' Int value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' IntProgress widget
#'
#' @param bar_style Use a predefined styling for the progress bar.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param max Max value
#' @param min Min value
#' @param orientation Vertical or horizontal.
#' @param value Int value
#' 
#' @param style Must inherit from [jupyter.widget.ProgressStyle].
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
IntProgress <- function(
  bar_style = "",
  description = "",
  description_allow_html = FALSE,
  max = 100L,
  min = 0L,
  orientation = "horizontal",
  value = 0L,
  style = ProgressStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.IntProgress$new(
    bar_style = bar_style,
    description = description,
    description_allow_html = description_allow_html,
    max = max,
    min = min,
    orientation = orientation,
    value = value,
    style = style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.IntProgress", "bar_style", unbox_one_of(c("success", "info", "warning", "danger"), allow_null = FALSE, allow_empty = TRUE))
  set_widget_state_check("jupyter.widget.IntProgress", "orientation", unbox_one_of(c("horizontal", "vertical"), allow_null = FALSE, allow_empty = FALSE))
})

#' FloatProgress widget
#'
#' @export
jupyter.widget.FloatProgress <- R6::R6Class("jupyter.widget.FloatProgress", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param bar_style Use a predefined styling for the progress bar.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param max Max value
    #' @param min Min value
    #' @param orientation Vertical or horizontal.
    #' @param value Float value
    #' @param style Must inherit from [jupyter.widget.ProgressStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.FloatProgress' widget
    initialize = function(
      bar_style = "",
      description = "",
      description_allow_html = FALSE,
      max = 100,
      min = 0,
      orientation = "horizontal",
      value = 0,
      style = ProgressStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        bar_style = self$check_state('bar_style', bar_style),
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        max = self$check_state('max', max),
        min = self$check_state('min', min),
        orientation = self$check_state('orientation', orientation),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "FloatProgressModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "ProgressView",
        style = style, 
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field bar_style
    #' Use a predefined styling for the progress bar.
    bar_style = function(x) if(missing(x)) private$state_[['bar_style']] else self$update(bar_style = self$check_state('bar_style', x)),
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field max
    #' Max value
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x)),
    
    #' @field min
    #' Min value
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x)),
    
    #' @field orientation
    #' Vertical or horizontal.
    orientation = function(x) if(missing(x)) private$state_[['orientation']] else self$update(orientation = self$check_state('orientation', x)),
    
    #' @field value
    #' Float value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' FloatProgress widget
#'
#' @param bar_style Use a predefined styling for the progress bar.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param max Max value
#' @param min Min value
#' @param orientation Vertical or horizontal.
#' @param value Float value
#' 
#' @param style Must inherit from [jupyter.widget.ProgressStyle].
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
FloatProgress <- function(
  bar_style = "",
  description = "",
  description_allow_html = FALSE,
  max = 100,
  min = 0,
  orientation = "horizontal",
  value = 0,
  style = ProgressStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.FloatProgress$new(
    bar_style = bar_style,
    description = description,
    description_allow_html = description_allow_html,
    max = max,
    min = min,
    orientation = orientation,
    value = value,
    style = style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.FloatProgress", "bar_style", unbox_one_of(c("success", "info", "warning", "danger"), allow_null = FALSE, allow_empty = TRUE))
  set_widget_state_check("jupyter.widget.FloatProgress", "orientation", unbox_one_of(c("horizontal", "vertical"), allow_null = FALSE, allow_empty = FALSE))
})

#' Password widget
#'
#' @export
jupyter.widget.Password <- R6::R6Class("jupyter.widget.Password", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param placeholder Placeholder text to display when nothing has been typed
    #' @param value String value
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Password' widget
    initialize = function(
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      placeholder = "\U{200B}",
      value = "",

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        continuous_update = self$check_state('continuous_update', continuous_update),
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        placeholder = self$check_state('placeholder', placeholder),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "PasswordModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "PasswordView",
        
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field continuous_update
    #' Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x)),
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field placeholder
    #' Placeholder text to display when nothing has been typed
    placeholder = function(x) if(missing(x)) private$state_[['placeholder']] else self$update(placeholder = self$check_state('placeholder', x)),
    
    #' @field value
    #' String value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' Password widget
#'
#' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param placeholder Placeholder text to display when nothing has been typed
#' @param value String value
#' 
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Password <- function(
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  placeholder = "\U{200B}",
  value = "",
  ...,
  error_call = current_env()
){
  jupyter.widget.Password$new(
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    placeholder = placeholder,
    value = value,
    ...,
    error_call = error_call
  )
}


#' Box widget
#'
#' @export
jupyter.widget.Box <- R6::R6Class("jupyter.widget.Box", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param box_style Use a predefined styling for the box.
    #' @param children List of widget children
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Box' widget
    initialize = function(
      box_style = "",
      children = list(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        box_style = self$check_state('box_style', box_style),
        children = self$check_state('children', children)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "BoxModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "BoxView",
        
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field box_style
    #' Use a predefined styling for the box.
    box_style = function(x) if(missing(x)) private$state_[['box_style']] else self$update(box_style = self$check_state('box_style', x)),
    
    #' @field children
    #' List of widget children
    children = function(x) if(missing(x)) private$state_[['children']] else self$update(children = self$check_state('children', x))
  )
)

#' Box widget
#'
#' @param box_style Use a predefined styling for the box.
#' @param children List of widget children
#' 
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Box <- function(
  box_style = "",
  children = list(),
  ...,
  error_call = current_env()
){
  jupyter.widget.Box$new(
    box_style = box_style,
    children = children,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.Box", "box_style", unbox_one_of(c("success", "info", "warning", "danger"), allow_null = TRUE, allow_empty = TRUE))
})

#' HBox widget
#'
#' @export
jupyter.widget.HBox <- R6::R6Class("jupyter.widget.HBox", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param box_style Use a predefined styling for the box.
    #' @param children List of widget children
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.HBox' widget
    initialize = function(
      box_style = "",
      children = list(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        box_style = self$check_state('box_style', box_style),
        children = self$check_state('children', children)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "HBoxModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "HBoxView",
        
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field box_style
    #' Use a predefined styling for the box.
    box_style = function(x) if(missing(x)) private$state_[['box_style']] else self$update(box_style = self$check_state('box_style', x)),
    
    #' @field children
    #' List of widget children
    children = function(x) if(missing(x)) private$state_[['children']] else self$update(children = self$check_state('children', x))
  )
)

#' HBox widget
#'
#' @param box_style Use a predefined styling for the box.
#' @param children List of widget children
#' 
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
HBox <- function(
  box_style = "",
  children = list(),
  ...,
  error_call = current_env()
){
  jupyter.widget.HBox$new(
    box_style = box_style,
    children = children,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.HBox", "box_style", unbox_one_of(c("success", "info", "warning", "danger"), allow_null = TRUE, allow_empty = TRUE))
})

#' VBox widget
#'
#' @export
jupyter.widget.VBox <- R6::R6Class("jupyter.widget.VBox", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param box_style Use a predefined styling for the box.
    #' @param children List of widget children
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.VBox' widget
    initialize = function(
      box_style = "",
      children = list(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        box_style = self$check_state('box_style', box_style),
        children = self$check_state('children', children)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "VBoxModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "VBoxView",
        
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field box_style
    #' Use a predefined styling for the box.
    box_style = function(x) if(missing(x)) private$state_[['box_style']] else self$update(box_style = self$check_state('box_style', x)),
    
    #' @field children
    #' List of widget children
    children = function(x) if(missing(x)) private$state_[['children']] else self$update(children = self$check_state('children', x))
  )
)

#' VBox widget
#'
#' @param box_style Use a predefined styling for the box.
#' @param children List of widget children
#' 
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
VBox <- function(
  box_style = "",
  children = list(),
  ...,
  error_call = current_env()
){
  jupyter.widget.VBox$new(
    box_style = box_style,
    children = children,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.VBox", "box_style", unbox_one_of(c("success", "info", "warning", "danger"), allow_null = TRUE, allow_empty = TRUE))
})

#' GridBox widget
#'
#' @export
jupyter.widget.GridBox <- R6::R6Class("jupyter.widget.GridBox", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param box_style Use a predefined styling for the box.
    #' @param children List of widget children
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.GridBox' widget
    initialize = function(
      box_style = "",
      children = list(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        box_style = self$check_state('box_style', box_style),
        children = self$check_state('children', children)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "GridBoxModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "GridBoxView",
        
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field box_style
    #' Use a predefined styling for the box.
    box_style = function(x) if(missing(x)) private$state_[['box_style']] else self$update(box_style = self$check_state('box_style', x)),
    
    #' @field children
    #' List of widget children
    children = function(x) if(missing(x)) private$state_[['children']] else self$update(children = self$check_state('children', x))
  )
)

#' GridBox widget
#'
#' @param box_style Use a predefined styling for the box.
#' @param children List of widget children
#' 
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
GridBox <- function(
  box_style = "",
  children = list(),
  ...,
  error_call = current_env()
){
  jupyter.widget.GridBox$new(
    box_style = box_style,
    children = children,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.GridBox", "box_style", unbox_one_of(c("success", "info", "warning", "danger"), allow_null = TRUE, allow_empty = TRUE))
})

#' Tab widget
#'
#' @export
jupyter.widget.Tab <- R6::R6Class("jupyter.widget.Tab", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param box_style Use a predefined styling for the box.
    #' @param children List of widget children
    #' @param selected_index The index of the selected page. This is either an integer selecting a particular sub-widget, or None to have no widgets selected.
    #' @param titles Titles of the pages
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Tab' widget
    initialize = function(
      box_style = "",
      children = list(),
      selected_index = NULL,
      titles = list(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        box_style = self$check_state('box_style', box_style),
        children = self$check_state('children', children),
        selected_index = self$check_state('selected_index', selected_index),
        titles = self$check_state('titles', titles)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "TabModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "TabView",
        
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field box_style
    #' Use a predefined styling for the box.
    box_style = function(x) if(missing(x)) private$state_[['box_style']] else self$update(box_style = self$check_state('box_style', x)),
    
    #' @field children
    #' List of widget children
    children = function(x) if(missing(x)) private$state_[['children']] else self$update(children = self$check_state('children', x)),
    
    #' @field selected_index
    #' The index of the selected page. This is either an integer selecting a particular sub-widget, or None to have no widgets selected.
    selected_index = function(x) if(missing(x)) private$state_[['selected_index']] else self$update(selected_index = self$check_state('selected_index', x)),
    
    #' @field titles
    #' Titles of the pages
    titles = function(x) if(missing(x)) private$state_[['titles']] else self$update(titles = self$check_state('titles', x))
  )
)

#' Tab widget
#'
#' @param box_style Use a predefined styling for the box.
#' @param children List of widget children
#' @param selected_index The index of the selected page. This is either an integer selecting a particular sub-widget, or None to have no widgets selected.
#' @param titles Titles of the pages
#' 
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Tab <- function(
  box_style = "",
  children = list(),
  selected_index = NULL,
  titles = list(),
  ...,
  error_call = current_env()
){
  jupyter.widget.Tab$new(
    box_style = box_style,
    children = children,
    selected_index = selected_index,
    titles = titles,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.Tab", "box_style", unbox_one_of(c("success", "info", "warning", "danger"), allow_null = TRUE, allow_empty = TRUE))
})

#' Stack widget
#'
#' @export
jupyter.widget.Stack <- R6::R6Class("jupyter.widget.Stack", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param box_style Use a predefined styling for the box.
    #' @param children List of widget children
    #' @param selected_index The index of the selected page. This is either an integer selecting a particular sub-widget, or None to have no widgets selected.
    #' @param titles Titles of the pages
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Stack' widget
    initialize = function(
      box_style = "",
      children = list(),
      selected_index = NULL,
      titles = list(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        box_style = self$check_state('box_style', box_style),
        children = self$check_state('children', children),
        selected_index = self$check_state('selected_index', selected_index),
        titles = self$check_state('titles', titles)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "StackModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "StackView",
        
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field box_style
    #' Use a predefined styling for the box.
    box_style = function(x) if(missing(x)) private$state_[['box_style']] else self$update(box_style = self$check_state('box_style', x)),
    
    #' @field children
    #' List of widget children
    children = function(x) if(missing(x)) private$state_[['children']] else self$update(children = self$check_state('children', x)),
    
    #' @field selected_index
    #' The index of the selected page. This is either an integer selecting a particular sub-widget, or None to have no widgets selected.
    selected_index = function(x) if(missing(x)) private$state_[['selected_index']] else self$update(selected_index = self$check_state('selected_index', x)),
    
    #' @field titles
    #' Titles of the pages
    titles = function(x) if(missing(x)) private$state_[['titles']] else self$update(titles = self$check_state('titles', x))
  )
)

#' Stack widget
#'
#' @param box_style Use a predefined styling for the box.
#' @param children List of widget children
#' @param selected_index The index of the selected page. This is either an integer selecting a particular sub-widget, or None to have no widgets selected.
#' @param titles Titles of the pages
#' 
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Stack <- function(
  box_style = "",
  children = list(),
  selected_index = NULL,
  titles = list(),
  ...,
  error_call = current_env()
){
  jupyter.widget.Stack$new(
    box_style = box_style,
    children = children,
    selected_index = selected_index,
    titles = titles,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.Stack", "box_style", unbox_one_of(c("success", "info", "warning", "danger"), allow_null = TRUE, allow_empty = TRUE))
})

#' Button widget
#'
#' @export
jupyter.widget.Button <- R6::R6Class("jupyter.widget.Button", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param button_style Use a predefined styling for the button.
    #' @param description Button label.
    #' @param disabled Enable or disable user changes.
    #' @param icon Font-awesome icon names, without the 'fa-' prefix.
    #' @param style Must inherit from [jupyter.widget.ButtonStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Button' widget
    initialize = function(
      button_style = "",
      description = "",
      disabled = FALSE,
      icon = "",
      style = ButtonStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        button_style = self$check_state('button_style', button_style),
        description = self$check_state('description', description),
        disabled = self$check_state('disabled', disabled),
        icon = self$check_state('icon', icon)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "ButtonModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "ButtonView",
        style = style, 
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field button_style
    #' Use a predefined styling for the button.
    button_style = function(x) if(missing(x)) private$state_[['button_style']] else self$update(button_style = self$check_state('button_style', x)),
    
    #' @field description
    #' Button label.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field disabled
    #' Enable or disable user changes.
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field icon
    #' Font-awesome icon names, without the 'fa-' prefix.
    icon = function(x) if(missing(x)) private$state_[['icon']] else self$update(icon = self$check_state('icon', x))
  )
)

#' Button widget
#'
#' @param button_style Use a predefined styling for the button.
#' @param description Button label.
#' @param disabled Enable or disable user changes.
#' @param icon Font-awesome icon names, without the 'fa-' prefix.
#' 
#' @param style Must inherit from [jupyter.widget.ButtonStyle].
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Button <- function(
  button_style = "",
  description = "",
  disabled = FALSE,
  icon = "",
  style = ButtonStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.Button$new(
    button_style = button_style,
    description = description,
    disabled = disabled,
    icon = icon,
    style = style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.Button", "button_style", unbox_one_of(c("primary", "success", "info", "warning", "danger"), allow_null = TRUE, allow_empty = TRUE))
})

#' Textarea widget
#'
#' @export
jupyter.widget.Textarea <- R6::R6Class("jupyter.widget.Textarea", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param placeholder Placeholder text to display when nothing has been typed
    #' @param rows The number of rows to display.
    #' @param value String value
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Textarea' widget
    initialize = function(
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      placeholder = "\U{200B}",
      rows = NULL,
      value = "",

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        continuous_update = self$check_state('continuous_update', continuous_update),
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        placeholder = self$check_state('placeholder', placeholder),
        rows = self$check_state('rows', rows),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "TextareaModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "TextareaView",
        
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field continuous_update
    #' Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x)),
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field placeholder
    #' Placeholder text to display when nothing has been typed
    placeholder = function(x) if(missing(x)) private$state_[['placeholder']] else self$update(placeholder = self$check_state('placeholder', x)),
    
    #' @field rows
    #' The number of rows to display.
    rows = function(x) if(missing(x)) private$state_[['rows']] else self$update(rows = self$check_state('rows', x)),
    
    #' @field value
    #' String value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' Textarea widget
#'
#' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param placeholder Placeholder text to display when nothing has been typed
#' @param rows The number of rows to display.
#' @param value String value
#' 
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Textarea <- function(
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  placeholder = "\U{200B}",
  rows = NULL,
  value = "",
  ...,
  error_call = current_env()
){
  jupyter.widget.Textarea$new(
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    placeholder = placeholder,
    rows = rows,
    value = value,
    ...,
    error_call = error_call
  )
}


#' Time widget
#'
#' @export
jupyter.widget.Time <- R6::R6Class("jupyter.widget.Time", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes.
    #' @param max (undocumented)
    #' @param min (undocumented)
    #' @param step The time step to use for the picker, in seconds, or "any".
    #' @param value (undocumented)
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Time' widget
    initialize = function(
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      max = NULL,
      min = NULL,
      step = 60L,
      value = NULL,

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        description = self$check_state('description', description),
        description_allow_html = self$check_state('description_allow_html', description_allow_html),
        disabled = self$check_state('disabled', disabled),
        max = self$check_state('max', max),
        min = self$check_state('min', min),
        step = self$check_state('step', step),
        value = self$check_state('value', value)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "TimeModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "TimeView",
        
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(
    
    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x)),
    
    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x)),
    
    #' @field disabled
    #' Enable or disable user changes.
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x)),
    
    #' @field max
    #' 
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x)),
    
    #' @field min
    #' 
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x)),
    
    #' @field step
    #' The time step to use for the picker, in seconds, or "any".
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x)),
    
    #' @field value
    #' 
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x))
  )
)

#' Time widget
#'
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes.
#' @param max (undocumented)
#' @param min (undocumented)
#' @param step The time step to use for the picker, in seconds, or "any".
#' @param value (undocumented)
#' 
#' 
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Time <- function(
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  max = NULL,
  min = NULL,
  step = 60L,
  value = NULL,
  ...,
  error_call = current_env()
){
  jupyter.widget.Time$new(
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    max = max,
    min = min,
    step = step,
    value = value,
    ...,
    error_call = error_call
  )
}


