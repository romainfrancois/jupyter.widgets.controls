# Generated by jupyter.widgets.controls/data-raw/generated.R: do not edit by hand

#' Accordion widget
#'
#' @export
jupyter.widget.Accordion <- R6::R6Class("jupyter.widget.Accordion", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param children List of widget children
    #' @param box_style Use a predefined styling for the box.
    #' @param selected_index The index of the selected page. This is either an integer selecting a particular sub-widget, or None to have no widgets selected.
    #' @param titles Titles of the pages
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Accordion' widget
    initialize = function(
      children = list(),
      box_style = "",
      selected_index = NULL,
      titles = list(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        children = self$check_state('children', children, error_call = error_call),
        box_style = self$check_state('box_style', box_style, error_call = error_call),
        selected_index = self$check_state('selected_index', selected_index, error_call = error_call),
        titles = self$check_state('titles', titles, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "AccordionModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "AccordionView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field children
    #' List of widget children
    children = function(x) if(missing(x)) private$state_[['children']] else self$update(children = self$check_state('children', x, error_call = quote(Accordion$children))),

    #' @field box_style
    #' Use a predefined styling for the box.
    box_style = function(x) if(missing(x)) private$state_[['box_style']] else self$update(box_style = self$check_state('box_style', x, error_call = quote(Accordion$box_style))),

    #' @field selected_index
    #' The index of the selected page. This is either an integer selecting a particular sub-widget, or None to have no widgets selected.
    selected_index = function(x) if(missing(x)) private$state_[['selected_index']] else self$update(selected_index = self$check_state('selected_index', x, error_call = quote(Accordion$selected_index))),

    #' @field titles
    #' Titles of the pages
    titles = function(x) if(missing(x)) private$state_[['titles']] else self$update(titles = self$check_state('titles', x, error_call = quote(Accordion$titles)))
  ),

  private = list(
    children_ = list()
  )
)

#' Accordion widget
#'
#' @param children List of widget children
#' @param box_style Use a predefined styling for the box.
#' @param selected_index The index of the selected page. This is either an integer selecting a particular sub-widget, or None to have no widgets selected.
#' @param titles Titles of the pages
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Accordion <- function(
  children = list(),
  box_style = "",
  selected_index = NULL,
  titles = list(),
  ...,
  error_call = current_env()
){
  jupyter.widget.Accordion$new(
    children = children,
    box_style = box_style,
    selected_index = selected_index,
    titles = titles,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.Accordion", "children", check_state_children)
  set_widget_state_check("jupyter.widget.Accordion", "box_style", unbox_one_of(c("success", "info", "warning", "danger"), allow_null = TRUE, allow_empty = TRUE))
})

#' Checkbox widget
#'
#' @export
jupyter.widget.Checkbox <- R6::R6Class("jupyter.widget.Checkbox", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value Bool value
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes.
    #' @param indent Indent the control to align with other controls with a description.
    #' @param style Must inherit from [jupyter.widget.CheckboxStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Checkbox' widget
    initialize = function(
      value = FALSE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      indent = TRUE,
      style = CheckboxStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call),
        indent = self$check_state('indent', indent, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "CheckboxModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "CheckboxView",
        style = style,
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' Bool value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(Checkbox$value))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(Checkbox$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(Checkbox$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes.
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(Checkbox$disabled))),

    #' @field indent
    #' Indent the control to align with other controls with a description.
    indent = function(x) if(missing(x)) private$state_[['indent']] else self$update(indent = self$check_state('indent', x, error_call = quote(Checkbox$indent)))
  ),

  private = list(

  )
)

#' Checkbox widget
#'
#' @param value Bool value
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes.
#' @param indent Indent the control to align with other controls with a description.
#'
#' @param style Must inherit from [jupyter.widget.CheckboxStyle].
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Checkbox <- function(
  value = FALSE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  indent = TRUE,
  style = CheckboxStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.Checkbox$new(
    value = value,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    indent = indent,
    style = style,
    ...,
    error_call = error_call
  )
}


#' ColorPicker widget
#'
#' @export
jupyter.widget.ColorPicker <- R6::R6Class("jupyter.widget.ColorPicker", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value The color value.
    #' @param concise Display short version with just a color selector.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes.
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.ColorPicker' widget
    initialize = function(
      value = "black",
      concise = FALSE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        concise = self$check_state('concise', concise, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "ColorPickerModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "ColorPickerView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' The color value.
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(ColorPicker$value))),

    #' @field concise
    #' Display short version with just a color selector.
    concise = function(x) if(missing(x)) private$state_[['concise']] else self$update(concise = self$check_state('concise', x, error_call = quote(ColorPicker$concise))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(ColorPicker$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(ColorPicker$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes.
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(ColorPicker$disabled)))
  ),

  private = list(

  )
)

#' ColorPicker widget
#'
#' @param value The color value.
#' @param concise Display short version with just a color selector.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes.
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
ColorPicker <- function(
  value = "black",
  concise = FALSE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  ...,
  error_call = current_env()
){
  jupyter.widget.ColorPicker$new(
    value = value,
    concise = concise,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    ...,
    error_call = error_call
  )
}


#' ColorsInput widget
#'
#' @export
jupyter.widget.ColorsInput <- R6::R6Class("jupyter.widget.ColorsInput", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value List of string tags
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param placeholder (undocumented)
    #' @param allow_duplicates (undocumented)
    #' @param allowed_tags (undocumented)
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.ColorsInput' widget
    initialize = function(
      value = list(),
      description = "",
      description_allow_html = FALSE,
      placeholder = "\U{200B}",
      allow_duplicates = TRUE,
      allowed_tags = list(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        placeholder = self$check_state('placeholder', placeholder, error_call = error_call),
        allow_duplicates = self$check_state('allow_duplicates', allow_duplicates, error_call = error_call),
        allowed_tags = self$check_state('allowed_tags', allowed_tags, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "ColorsInputModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "ColorsInputView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' List of string tags
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(ColorsInput$value))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(ColorsInput$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(ColorsInput$description_allow_html))),

    #' @field placeholder
    #'
    placeholder = function(x) if(missing(x)) private$state_[['placeholder']] else self$update(placeholder = self$check_state('placeholder', x, error_call = quote(ColorsInput$placeholder))),

    #' @field allow_duplicates
    #'
    allow_duplicates = function(x) if(missing(x)) private$state_[['allow_duplicates']] else self$update(allow_duplicates = self$check_state('allow_duplicates', x, error_call = quote(ColorsInput$allow_duplicates))),

    #' @field allowed_tags
    #'
    allowed_tags = function(x) if(missing(x)) private$state_[['allowed_tags']] else self$update(allowed_tags = self$check_state('allowed_tags', x, error_call = quote(ColorsInput$allowed_tags)))
  ),

  private = list(

  )
)

#' ColorsInput widget
#'
#' @param value List of string tags
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param placeholder (undocumented)
#' @param allow_duplicates (undocumented)
#' @param allowed_tags (undocumented)
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
ColorsInput <- function(
  value = list(),
  description = "",
  description_allow_html = FALSE,
  placeholder = "\U{200B}",
  allow_duplicates = TRUE,
  allowed_tags = list(),
  ...,
  error_call = current_env()
){
  jupyter.widget.ColorsInput$new(
    value = value,
    description = description,
    description_allow_html = description_allow_html,
    placeholder = placeholder,
    allow_duplicates = allow_duplicates,
    allowed_tags = allowed_tags,
    ...,
    error_call = error_call
  )
}


#' Combobox widget
#'
#' @export
jupyter.widget.Combobox <- R6::R6Class("jupyter.widget.Combobox", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value String value
    #' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param ensure_option If set, ensure value is in options. Implies continuous_update=False.
    #' @param options Dropdown options for the combobox
    #' @param placeholder Placeholder text to display when nothing has been typed
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Combobox' widget
    initialize = function(
      value = "",
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      ensure_option = FALSE,
      options = list(),
      placeholder = "\U{200B}",

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        continuous_update = self$check_state('continuous_update', continuous_update, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call),
        ensure_option = self$check_state('ensure_option', ensure_option, error_call = error_call),
        options = self$check_state('options', options, error_call = error_call),
        placeholder = self$check_state('placeholder', placeholder, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "ComboboxModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "ComboboxView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' String value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(Combobox$value))),

    #' @field continuous_update
    #' Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x, error_call = quote(Combobox$continuous_update))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(Combobox$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(Combobox$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(Combobox$disabled))),

    #' @field ensure_option
    #' If set, ensure value is in options. Implies continuous_update=False.
    ensure_option = function(x) if(missing(x)) private$state_[['ensure_option']] else self$update(ensure_option = self$check_state('ensure_option', x, error_call = quote(Combobox$ensure_option))),

    #' @field options
    #' Dropdown options for the combobox
    options = function(x) if(missing(x)) private$state_[['options']] else self$update(options = self$check_state('options', x, error_call = quote(Combobox$options))),

    #' @field placeholder
    #' Placeholder text to display when nothing has been typed
    placeholder = function(x) if(missing(x)) private$state_[['placeholder']] else self$update(placeholder = self$check_state('placeholder', x, error_call = quote(Combobox$placeholder)))
  ),

  private = list(

  )
)

#' Combobox widget
#'
#' @param value String value
#' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param ensure_option If set, ensure value is in options. Implies continuous_update=False.
#' @param options Dropdown options for the combobox
#' @param placeholder Placeholder text to display when nothing has been typed
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Combobox <- function(
  value = "",
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  ensure_option = FALSE,
  options = list(),
  placeholder = "\U{200B}",
  ...,
  error_call = current_env()
){
  jupyter.widget.Combobox$new(
    value = value,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    ensure_option = ensure_option,
    options = options,
    placeholder = placeholder,
    ...,
    error_call = error_call
  )
}


#' DatePicker widget
#'
#' @export
jupyter.widget.DatePicker <- R6::R6Class("jupyter.widget.DatePicker", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value (undocumented)
    #' @param min (undocumented)
    #' @param max (undocumented)
    #' @param step The date step to use for the picker, in days, or "any".
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes.
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.DatePicker' widget
    initialize = function(
      value = NULL,
      min = NULL,
      max = NULL,
      step = 1L,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        min = self$check_state('min', min, error_call = error_call),
        max = self$check_state('max', max, error_call = error_call),
        step = self$check_state('step', step, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "DatePickerModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "DatePickerView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #'
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(DatePicker$value))),

    #' @field min
    #'
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x, error_call = quote(DatePicker$min))),

    #' @field max
    #'
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x, error_call = quote(DatePicker$max))),

    #' @field step
    #' The date step to use for the picker, in days, or "any".
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x, error_call = quote(DatePicker$step))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(DatePicker$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(DatePicker$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes.
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(DatePicker$disabled)))
  ),

  private = list(

  )
)

#' DatePicker widget
#'
#' @param value (undocumented)
#' @param min (undocumented)
#' @param max (undocumented)
#' @param step The date step to use for the picker, in days, or "any".
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes.
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
DatePicker <- function(
  value = NULL,
  min = NULL,
  max = NULL,
  step = 1L,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  ...,
  error_call = current_env()
){
  jupyter.widget.DatePicker$new(
    value = value,
    min = min,
    max = max,
    step = step,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    ...,
    error_call = error_call
  )
}


#' Datetime widget
#'
#' @export
jupyter.widget.Datetime <- R6::R6Class("jupyter.widget.Datetime", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value (undocumented)
    #' @param min (undocumented)
    #' @param max (undocumented)
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes.
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Datetime' widget
    initialize = function(
      value = NULL,
      min = NULL,
      max = NULL,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        min = self$check_state('min', min, error_call = error_call),
        max = self$check_state('max', max, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "DatetimeModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "DatetimeView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #'
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(Datetime$value))),

    #' @field min
    #'
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x, error_call = quote(Datetime$min))),

    #' @field max
    #'
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x, error_call = quote(Datetime$max))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(Datetime$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(Datetime$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes.
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(Datetime$disabled)))
  ),

  private = list(

  )
)

#' Datetime widget
#'
#' @param value (undocumented)
#' @param min (undocumented)
#' @param max (undocumented)
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes.
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Datetime <- function(
  value = NULL,
  min = NULL,
  max = NULL,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  ...,
  error_call = current_env()
){
  jupyter.widget.Datetime$new(
    value = value,
    min = min,
    max = max,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    ...,
    error_call = error_call
  )
}


#' NaiveDatetime widget
#'
#' @export
jupyter.widget.NaiveDatetime <- R6::R6Class("jupyter.widget.NaiveDatetime", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value (undocumented)
    #' @param min (undocumented)
    #' @param max (undocumented)
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes.
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.NaiveDatetime' widget
    initialize = function(
      value = NULL,
      min = NULL,
      max = NULL,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        min = self$check_state('min', min, error_call = error_call),
        max = self$check_state('max', max, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "NaiveDatetimeModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "DatetimeView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #'
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(NaiveDatetime$value))),

    #' @field min
    #'
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x, error_call = quote(NaiveDatetime$min))),

    #' @field max
    #'
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x, error_call = quote(NaiveDatetime$max))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(NaiveDatetime$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(NaiveDatetime$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes.
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(NaiveDatetime$disabled)))
  ),

  private = list(

  )
)

#' NaiveDatetime widget
#'
#' @param value (undocumented)
#' @param min (undocumented)
#' @param max (undocumented)
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes.
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
NaiveDatetime <- function(
  value = NULL,
  min = NULL,
  max = NULL,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  ...,
  error_call = current_env()
){
  jupyter.widget.NaiveDatetime$new(
    value = value,
    min = min,
    max = max,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    ...,
    error_call = error_call
  )
}


#' IntSlider widget
#'
#' @export
jupyter.widget.IntSlider <- R6::R6Class("jupyter.widget.IntSlider", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value Int value
    #' @param min Min value
    #' @param max Max value
    #' @param step Minimum step to increment the value
    #' @param behavior Slider dragging behavior.
    #' @param continuous_update Update the value of the widget as the user is holding the slider.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param orientation Vertical or horizontal.
    #' @param readout Display the current value of the slider next to it.
    #' @param readout_format Format for the readout
    #' @param style Must inherit from [jupyter.widget.SliderStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.IntSlider' widget
    initialize = function(
      value = 0L,
      min = 0L,
      max = 100L,
      step = 1L,
      behavior = "drag-tap",
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      orientation = "horizontal",
      readout = TRUE,
      readout_format = "d",
      style = SliderStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        min = self$check_state('min', min, error_call = error_call),
        max = self$check_state('max', max, error_call = error_call),
        step = self$check_state('step', step, error_call = error_call),
        behavior = self$check_state('behavior', behavior, error_call = error_call),
        continuous_update = self$check_state('continuous_update', continuous_update, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call),
        orientation = self$check_state('orientation', orientation, error_call = error_call),
        readout = self$check_state('readout', readout, error_call = error_call),
        readout_format = self$check_state('readout_format', readout_format, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "IntSliderModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "IntSliderView",
        style = style,
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' Int value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(IntSlider$value))),

    #' @field min
    #' Min value
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x, error_call = quote(IntSlider$min))),

    #' @field max
    #' Max value
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x, error_call = quote(IntSlider$max))),

    #' @field step
    #' Minimum step to increment the value
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x, error_call = quote(IntSlider$step))),

    #' @field behavior
    #' Slider dragging behavior.
    behavior = function(x) if(missing(x)) private$state_[['behavior']] else self$update(behavior = self$check_state('behavior', x, error_call = quote(IntSlider$behavior))),

    #' @field continuous_update
    #' Update the value of the widget as the user is holding the slider.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x, error_call = quote(IntSlider$continuous_update))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(IntSlider$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(IntSlider$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(IntSlider$disabled))),

    #' @field orientation
    #' Vertical or horizontal.
    orientation = function(x) if(missing(x)) private$state_[['orientation']] else self$update(orientation = self$check_state('orientation', x, error_call = quote(IntSlider$orientation))),

    #' @field readout
    #' Display the current value of the slider next to it.
    readout = function(x) if(missing(x)) private$state_[['readout']] else self$update(readout = self$check_state('readout', x, error_call = quote(IntSlider$readout))),

    #' @field readout_format
    #' Format for the readout
    readout_format = function(x) if(missing(x)) private$state_[['readout_format']] else self$update(readout_format = self$check_state('readout_format', x, error_call = quote(IntSlider$readout_format)))
  ),

  private = list(

  )
)

#' IntSlider widget
#'
#' @param value Int value
#' @param min Min value
#' @param max Max value
#' @param step Minimum step to increment the value
#' @param behavior Slider dragging behavior.
#' @param continuous_update Update the value of the widget as the user is holding the slider.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param orientation Vertical or horizontal.
#' @param readout Display the current value of the slider next to it.
#' @param readout_format Format for the readout
#'
#' @param style Must inherit from [jupyter.widget.SliderStyle].
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
IntSlider <- function(
  value = 0L,
  min = 0L,
  max = 100L,
  step = 1L,
  behavior = "drag-tap",
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  orientation = "horizontal",
  readout = TRUE,
  readout_format = "d",
  style = SliderStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.IntSlider$new(
    value = value,
    min = min,
    max = max,
    step = step,
    behavior = behavior,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    orientation = orientation,
    readout = readout,
    readout_format = readout_format,
    style = style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.IntSlider", "behavior", unbox_one_of(c("drag-tap", "drag-snap", "tap", "drag", "snap"), allow_null = FALSE, allow_empty = FALSE))
  set_widget_state_check("jupyter.widget.IntSlider", "orientation", unbox_one_of(c("horizontal", "vertical"), allow_null = FALSE, allow_empty = FALSE))
})

#' FloatSlider widget
#'
#' @export
jupyter.widget.FloatSlider <- R6::R6Class("jupyter.widget.FloatSlider", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value Float value
    #' @param min Min value
    #' @param max Max value
    #' @param step Minimum step to increment the value
    #' @param behavior Slider dragging behavior.
    #' @param continuous_update Update the value of the widget as the user is holding the slider.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param orientation Vertical or horizontal.
    #' @param readout Display the current value of the slider next to it.
    #' @param readout_format Format for the readout
    #' @param style Must inherit from [jupyter.widget.SliderStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.FloatSlider' widget
    initialize = function(
      value = 0,
      min = 0,
      max = 100,
      step = 0.1,
      behavior = "drag-tap",
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      orientation = "horizontal",
      readout = TRUE,
      readout_format = ".2f",
      style = SliderStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        min = self$check_state('min', min, error_call = error_call),
        max = self$check_state('max', max, error_call = error_call),
        step = self$check_state('step', step, error_call = error_call),
        behavior = self$check_state('behavior', behavior, error_call = error_call),
        continuous_update = self$check_state('continuous_update', continuous_update, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call),
        orientation = self$check_state('orientation', orientation, error_call = error_call),
        readout = self$check_state('readout', readout, error_call = error_call),
        readout_format = self$check_state('readout_format', readout_format, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "FloatSliderModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "FloatSliderView",
        style = style,
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' Float value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(FloatSlider$value))),

    #' @field min
    #' Min value
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x, error_call = quote(FloatSlider$min))),

    #' @field max
    #' Max value
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x, error_call = quote(FloatSlider$max))),

    #' @field step
    #' Minimum step to increment the value
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x, error_call = quote(FloatSlider$step))),

    #' @field behavior
    #' Slider dragging behavior.
    behavior = function(x) if(missing(x)) private$state_[['behavior']] else self$update(behavior = self$check_state('behavior', x, error_call = quote(FloatSlider$behavior))),

    #' @field continuous_update
    #' Update the value of the widget as the user is holding the slider.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x, error_call = quote(FloatSlider$continuous_update))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(FloatSlider$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(FloatSlider$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(FloatSlider$disabled))),

    #' @field orientation
    #' Vertical or horizontal.
    orientation = function(x) if(missing(x)) private$state_[['orientation']] else self$update(orientation = self$check_state('orientation', x, error_call = quote(FloatSlider$orientation))),

    #' @field readout
    #' Display the current value of the slider next to it.
    readout = function(x) if(missing(x)) private$state_[['readout']] else self$update(readout = self$check_state('readout', x, error_call = quote(FloatSlider$readout))),

    #' @field readout_format
    #' Format for the readout
    readout_format = function(x) if(missing(x)) private$state_[['readout_format']] else self$update(readout_format = self$check_state('readout_format', x, error_call = quote(FloatSlider$readout_format)))
  ),

  private = list(

  )
)

#' FloatSlider widget
#'
#' @param value Float value
#' @param min Min value
#' @param max Max value
#' @param step Minimum step to increment the value
#' @param behavior Slider dragging behavior.
#' @param continuous_update Update the value of the widget as the user is holding the slider.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param orientation Vertical or horizontal.
#' @param readout Display the current value of the slider next to it.
#' @param readout_format Format for the readout
#'
#' @param style Must inherit from [jupyter.widget.SliderStyle].
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
FloatSlider <- function(
  value = 0,
  min = 0,
  max = 100,
  step = 0.1,
  behavior = "drag-tap",
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  orientation = "horizontal",
  readout = TRUE,
  readout_format = ".2f",
  style = SliderStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.FloatSlider$new(
    value = value,
    min = min,
    max = max,
    step = step,
    behavior = behavior,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    orientation = orientation,
    readout = readout,
    readout_format = readout_format,
    style = style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.FloatSlider", "behavior", unbox_one_of(c("drag-tap", "drag-snap", "tap", "drag", "snap"), allow_null = FALSE, allow_empty = FALSE))
  set_widget_state_check("jupyter.widget.FloatSlider", "orientation", unbox_one_of(c("horizontal", "vertical"), allow_null = FALSE, allow_empty = FALSE))
})

#' FloatLogSlider widget
#'
#' @export
jupyter.widget.FloatLogSlider <- R6::R6Class("jupyter.widget.FloatLogSlider", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value Float value
    #' @param min Min value for the exponent
    #' @param max Max value for the exponent
    #' @param step Minimum step in the exponent to increment the value
    #' @param base Base for the logarithm
    #' @param behavior Slider dragging behavior.
    #' @param continuous_update Update the value of the widget as the user is holding the slider.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param orientation Vertical or horizontal.
    #' @param readout Display the current value of the slider next to it.
    #' @param readout_format Format for the readout
    #' @param style Must inherit from [jupyter.widget.SliderStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.FloatLogSlider' widget
    initialize = function(
      value = 1,
      min = 0,
      max = 4,
      step = 0.1,
      base = 10,
      behavior = "drag-tap",
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      orientation = "horizontal",
      readout = TRUE,
      readout_format = ".3g",
      style = SliderStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        min = self$check_state('min', min, error_call = error_call),
        max = self$check_state('max', max, error_call = error_call),
        step = self$check_state('step', step, error_call = error_call),
        base = self$check_state('base', base, error_call = error_call),
        behavior = self$check_state('behavior', behavior, error_call = error_call),
        continuous_update = self$check_state('continuous_update', continuous_update, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call),
        orientation = self$check_state('orientation', orientation, error_call = error_call),
        readout = self$check_state('readout', readout, error_call = error_call),
        readout_format = self$check_state('readout_format', readout_format, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "FloatLogSliderModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "FloatLogSliderView",
        style = style,
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' Float value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(FloatLogSlider$value))),

    #' @field min
    #' Min value for the exponent
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x, error_call = quote(FloatLogSlider$min))),

    #' @field max
    #' Max value for the exponent
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x, error_call = quote(FloatLogSlider$max))),

    #' @field step
    #' Minimum step in the exponent to increment the value
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x, error_call = quote(FloatLogSlider$step))),

    #' @field base
    #' Base for the logarithm
    base = function(x) if(missing(x)) private$state_[['base']] else self$update(base = self$check_state('base', x, error_call = quote(FloatLogSlider$base))),

    #' @field behavior
    #' Slider dragging behavior.
    behavior = function(x) if(missing(x)) private$state_[['behavior']] else self$update(behavior = self$check_state('behavior', x, error_call = quote(FloatLogSlider$behavior))),

    #' @field continuous_update
    #' Update the value of the widget as the user is holding the slider.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x, error_call = quote(FloatLogSlider$continuous_update))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(FloatLogSlider$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(FloatLogSlider$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(FloatLogSlider$disabled))),

    #' @field orientation
    #' Vertical or horizontal.
    orientation = function(x) if(missing(x)) private$state_[['orientation']] else self$update(orientation = self$check_state('orientation', x, error_call = quote(FloatLogSlider$orientation))),

    #' @field readout
    #' Display the current value of the slider next to it.
    readout = function(x) if(missing(x)) private$state_[['readout']] else self$update(readout = self$check_state('readout', x, error_call = quote(FloatLogSlider$readout))),

    #' @field readout_format
    #' Format for the readout
    readout_format = function(x) if(missing(x)) private$state_[['readout_format']] else self$update(readout_format = self$check_state('readout_format', x, error_call = quote(FloatLogSlider$readout_format)))
  ),

  private = list(

  )
)

#' FloatLogSlider widget
#'
#' @param value Float value
#' @param min Min value for the exponent
#' @param max Max value for the exponent
#' @param step Minimum step in the exponent to increment the value
#' @param base Base for the logarithm
#' @param behavior Slider dragging behavior.
#' @param continuous_update Update the value of the widget as the user is holding the slider.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param orientation Vertical or horizontal.
#' @param readout Display the current value of the slider next to it.
#' @param readout_format Format for the readout
#'
#' @param style Must inherit from [jupyter.widget.SliderStyle].
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
FloatLogSlider <- function(
  value = 1,
  min = 0,
  max = 4,
  step = 0.1,
  base = 10,
  behavior = "drag-tap",
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  orientation = "horizontal",
  readout = TRUE,
  readout_format = ".3g",
  style = SliderStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.FloatLogSlider$new(
    value = value,
    min = min,
    max = max,
    step = step,
    base = base,
    behavior = behavior,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    orientation = orientation,
    readout = readout,
    readout_format = readout_format,
    style = style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.FloatLogSlider", "behavior", unbox_one_of(c("drag-tap", "drag-snap", "tap", "drag", "snap"), allow_null = FALSE, allow_empty = FALSE))
  set_widget_state_check("jupyter.widget.FloatLogSlider", "orientation", unbox_one_of(c("horizontal", "vertical"), allow_null = FALSE, allow_empty = FALSE))
})

#' FloatRangeSlider widget
#'
#' @export
jupyter.widget.FloatRangeSlider <- R6::R6Class("jupyter.widget.FloatRangeSlider", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value Tuple of (lower, upper) bounds
    #' @param min Min value
    #' @param max Max value
    #' @param step Minimum step to increment the value
    #' @param behavior Slider dragging behavior.
    #' @param continuous_update Update the value of the widget as the user is sliding the slider.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param orientation Vertical or horizontal.
    #' @param readout Display the current value of the slider next to it.
    #' @param readout_format Format for the readout
    #' @param style Must inherit from [jupyter.widget.SliderStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.FloatRangeSlider' widget
    initialize = function(
      value = list(0, 1),
      min = 0,
      max = 100,
      step = 0.1,
      behavior = "drag-tap",
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      orientation = "horizontal",
      readout = TRUE,
      readout_format = ".2f",
      style = SliderStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        min = self$check_state('min', min, error_call = error_call),
        max = self$check_state('max', max, error_call = error_call),
        step = self$check_state('step', step, error_call = error_call),
        behavior = self$check_state('behavior', behavior, error_call = error_call),
        continuous_update = self$check_state('continuous_update', continuous_update, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call),
        orientation = self$check_state('orientation', orientation, error_call = error_call),
        readout = self$check_state('readout', readout, error_call = error_call),
        readout_format = self$check_state('readout_format', readout_format, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "FloatRangeSliderModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "FloatRangeSliderView",
        style = style,
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' Tuple of (lower, upper) bounds
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(FloatRangeSlider$value))),

    #' @field min
    #' Min value
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x, error_call = quote(FloatRangeSlider$min))),

    #' @field max
    #' Max value
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x, error_call = quote(FloatRangeSlider$max))),

    #' @field step
    #' Minimum step to increment the value
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x, error_call = quote(FloatRangeSlider$step))),

    #' @field behavior
    #' Slider dragging behavior.
    behavior = function(x) if(missing(x)) private$state_[['behavior']] else self$update(behavior = self$check_state('behavior', x, error_call = quote(FloatRangeSlider$behavior))),

    #' @field continuous_update
    #' Update the value of the widget as the user is sliding the slider.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x, error_call = quote(FloatRangeSlider$continuous_update))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(FloatRangeSlider$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(FloatRangeSlider$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(FloatRangeSlider$disabled))),

    #' @field orientation
    #' Vertical or horizontal.
    orientation = function(x) if(missing(x)) private$state_[['orientation']] else self$update(orientation = self$check_state('orientation', x, error_call = quote(FloatRangeSlider$orientation))),

    #' @field readout
    #' Display the current value of the slider next to it.
    readout = function(x) if(missing(x)) private$state_[['readout']] else self$update(readout = self$check_state('readout', x, error_call = quote(FloatRangeSlider$readout))),

    #' @field readout_format
    #' Format for the readout
    readout_format = function(x) if(missing(x)) private$state_[['readout_format']] else self$update(readout_format = self$check_state('readout_format', x, error_call = quote(FloatRangeSlider$readout_format)))
  ),

  private = list(

  )
)

#' FloatRangeSlider widget
#'
#' @param value Tuple of (lower, upper) bounds
#' @param min Min value
#' @param max Max value
#' @param step Minimum step to increment the value
#' @param behavior Slider dragging behavior.
#' @param continuous_update Update the value of the widget as the user is sliding the slider.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param orientation Vertical or horizontal.
#' @param readout Display the current value of the slider next to it.
#' @param readout_format Format for the readout
#'
#' @param style Must inherit from [jupyter.widget.SliderStyle].
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
FloatRangeSlider <- function(
  value = list(0, 1),
  min = 0,
  max = 100,
  step = 0.1,
  behavior = "drag-tap",
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  orientation = "horizontal",
  readout = TRUE,
  readout_format = ".2f",
  style = SliderStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.FloatRangeSlider$new(
    value = value,
    min = min,
    max = max,
    step = step,
    behavior = behavior,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    orientation = orientation,
    readout = readout,
    readout_format = readout_format,
    style = style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.FloatRangeSlider", "behavior", unbox_one_of(c("drag-tap", "drag-snap", "tap", "drag", "snap"), allow_null = FALSE, allow_empty = FALSE))
  set_widget_state_check("jupyter.widget.FloatRangeSlider", "orientation", unbox_one_of(c("horizontal", "vertical"), allow_null = FALSE, allow_empty = FALSE))
})

#' IntRangeSlider widget
#'
#' @export
jupyter.widget.IntRangeSlider <- R6::R6Class("jupyter.widget.IntRangeSlider", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value Tuple of (lower, upper) bounds
    #' @param min Min value
    #' @param max Max value
    #' @param step Minimum step that the value can take
    #' @param behavior Slider dragging behavior.
    #' @param continuous_update Update the value of the widget as the user is sliding the slider.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param orientation Vertical or horizontal.
    #' @param readout Display the current value of the slider next to it.
    #' @param readout_format Format for the readout
    #' @param style Must inherit from [jupyter.widget.SliderStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.IntRangeSlider' widget
    initialize = function(
      value = list(0L, 1L),
      min = 0L,
      max = 100L,
      step = 1L,
      behavior = "drag-tap",
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      orientation = "horizontal",
      readout = TRUE,
      readout_format = "d",
      style = SliderStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        min = self$check_state('min', min, error_call = error_call),
        max = self$check_state('max', max, error_call = error_call),
        step = self$check_state('step', step, error_call = error_call),
        behavior = self$check_state('behavior', behavior, error_call = error_call),
        continuous_update = self$check_state('continuous_update', continuous_update, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call),
        orientation = self$check_state('orientation', orientation, error_call = error_call),
        readout = self$check_state('readout', readout, error_call = error_call),
        readout_format = self$check_state('readout_format', readout_format, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "IntRangeSliderModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "IntRangeSliderView",
        style = style,
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' Tuple of (lower, upper) bounds
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(IntRangeSlider$value))),

    #' @field min
    #' Min value
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x, error_call = quote(IntRangeSlider$min))),

    #' @field max
    #' Max value
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x, error_call = quote(IntRangeSlider$max))),

    #' @field step
    #' Minimum step that the value can take
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x, error_call = quote(IntRangeSlider$step))),

    #' @field behavior
    #' Slider dragging behavior.
    behavior = function(x) if(missing(x)) private$state_[['behavior']] else self$update(behavior = self$check_state('behavior', x, error_call = quote(IntRangeSlider$behavior))),

    #' @field continuous_update
    #' Update the value of the widget as the user is sliding the slider.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x, error_call = quote(IntRangeSlider$continuous_update))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(IntRangeSlider$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(IntRangeSlider$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(IntRangeSlider$disabled))),

    #' @field orientation
    #' Vertical or horizontal.
    orientation = function(x) if(missing(x)) private$state_[['orientation']] else self$update(orientation = self$check_state('orientation', x, error_call = quote(IntRangeSlider$orientation))),

    #' @field readout
    #' Display the current value of the slider next to it.
    readout = function(x) if(missing(x)) private$state_[['readout']] else self$update(readout = self$check_state('readout', x, error_call = quote(IntRangeSlider$readout))),

    #' @field readout_format
    #' Format for the readout
    readout_format = function(x) if(missing(x)) private$state_[['readout_format']] else self$update(readout_format = self$check_state('readout_format', x, error_call = quote(IntRangeSlider$readout_format)))
  ),

  private = list(

  )
)

#' IntRangeSlider widget
#'
#' @param value Tuple of (lower, upper) bounds
#' @param min Min value
#' @param max Max value
#' @param step Minimum step that the value can take
#' @param behavior Slider dragging behavior.
#' @param continuous_update Update the value of the widget as the user is sliding the slider.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param orientation Vertical or horizontal.
#' @param readout Display the current value of the slider next to it.
#' @param readout_format Format for the readout
#'
#' @param style Must inherit from [jupyter.widget.SliderStyle].
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
IntRangeSlider <- function(
  value = list(0L, 1L),
  min = 0L,
  max = 100L,
  step = 1L,
  behavior = "drag-tap",
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  orientation = "horizontal",
  readout = TRUE,
  readout_format = "d",
  style = SliderStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.IntRangeSlider$new(
    value = value,
    min = min,
    max = max,
    step = step,
    behavior = behavior,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    orientation = orientation,
    readout = readout,
    readout_format = readout_format,
    style = style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.IntRangeSlider", "behavior", unbox_one_of(c("drag-tap", "drag-snap", "tap", "drag", "snap"), allow_null = FALSE, allow_empty = FALSE))
  set_widget_state_check("jupyter.widget.IntRangeSlider", "orientation", unbox_one_of(c("horizontal", "vertical"), allow_null = FALSE, allow_empty = FALSE))
})

#' Text widget
#'
#' @export
jupyter.widget.Text <- R6::R6Class("jupyter.widget.Text", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value String value
    #' @param placeholder Placeholder text to display when nothing has been typed
    #' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param style Must inherit from [jupyter.widget.TextStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Text' widget
    initialize = function(
      value = "",
      placeholder = "\U{200B}",
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      style = TextStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        placeholder = self$check_state('placeholder', placeholder, error_call = error_call),
        continuous_update = self$check_state('continuous_update', continuous_update, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "TextModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "TextView",
        style = style,
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' String value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(Text$value))),

    #' @field placeholder
    #' Placeholder text to display when nothing has been typed
    placeholder = function(x) if(missing(x)) private$state_[['placeholder']] else self$update(placeholder = self$check_state('placeholder', x, error_call = quote(Text$placeholder))),

    #' @field continuous_update
    #' Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x, error_call = quote(Text$continuous_update))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(Text$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(Text$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(Text$disabled)))
  ),

  private = list(

  )
)

#' Text widget
#'
#' @param value String value
#' @param placeholder Placeholder text to display when nothing has been typed
#' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#'
#' @param style Must inherit from [jupyter.widget.TextStyle].
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Text <- function(
  value = "",
  placeholder = "\U{200B}",
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  style = TextStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.Text$new(
    value = value,
    placeholder = placeholder,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    style = style,
    ...,
    error_call = error_call
  )
}


#' IntText widget
#'
#' @export
jupyter.widget.IntText <- R6::R6Class("jupyter.widget.IntText", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value Int value
    #' @param step Minimum step to increment the value
    #' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param style Must inherit from [jupyter.widget.TextStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.IntText' widget
    initialize = function(
      value = 0L,
      step = 1L,
      continuous_update = FALSE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      style = TextStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        step = self$check_state('step', step, error_call = error_call),
        continuous_update = self$check_state('continuous_update', continuous_update, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "IntTextModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "IntTextView",
        style = style,
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' Int value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(IntText$value))),

    #' @field step
    #' Minimum step to increment the value
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x, error_call = quote(IntText$step))),

    #' @field continuous_update
    #' Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x, error_call = quote(IntText$continuous_update))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(IntText$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(IntText$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(IntText$disabled)))
  ),

  private = list(

  )
)

#' IntText widget
#'
#' @param value Int value
#' @param step Minimum step to increment the value
#' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#'
#' @param style Must inherit from [jupyter.widget.TextStyle].
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
IntText <- function(
  value = 0L,
  step = 1L,
  continuous_update = FALSE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  style = TextStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.IntText$new(
    value = value,
    step = step,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    style = style,
    ...,
    error_call = error_call
  )
}


#' FloatText widget
#'
#' @export
jupyter.widget.FloatText <- R6::R6Class("jupyter.widget.FloatText", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value Float value
    #' @param step Minimum step to increment the value
    #' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param style Must inherit from [jupyter.widget.TextStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.FloatText' widget
    initialize = function(
      value = 0,
      step = NULL,
      continuous_update = FALSE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      style = TextStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        step = self$check_state('step', step, error_call = error_call),
        continuous_update = self$check_state('continuous_update', continuous_update, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "FloatTextModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "FloatTextView",
        style = style,
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' Float value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(FloatText$value))),

    #' @field step
    #' Minimum step to increment the value
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x, error_call = quote(FloatText$step))),

    #' @field continuous_update
    #' Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x, error_call = quote(FloatText$continuous_update))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(FloatText$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(FloatText$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(FloatText$disabled)))
  ),

  private = list(

  )
)

#' FloatText widget
#'
#' @param value Float value
#' @param step Minimum step to increment the value
#' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#'
#' @param style Must inherit from [jupyter.widget.TextStyle].
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
FloatText <- function(
  value = 0,
  step = NULL,
  continuous_update = FALSE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  style = TextStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.FloatText$new(
    value = value,
    step = step,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    style = style,
    ...,
    error_call = error_call
  )
}


#' BoundedIntText widget
#'
#' @export
jupyter.widget.BoundedIntText <- R6::R6Class("jupyter.widget.BoundedIntText", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value Int value
    #' @param min Min value
    #' @param max Max value
    #' @param step Minimum step to increment the value
    #' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param style Must inherit from [jupyter.widget.TextStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.BoundedIntText' widget
    initialize = function(
      value = 0L,
      min = 0L,
      max = 100L,
      step = 1L,
      continuous_update = FALSE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      style = TextStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        min = self$check_state('min', min, error_call = error_call),
        max = self$check_state('max', max, error_call = error_call),
        step = self$check_state('step', step, error_call = error_call),
        continuous_update = self$check_state('continuous_update', continuous_update, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "BoundedIntTextModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "IntTextView",
        style = style,
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' Int value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(BoundedIntText$value))),

    #' @field min
    #' Min value
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x, error_call = quote(BoundedIntText$min))),

    #' @field max
    #' Max value
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x, error_call = quote(BoundedIntText$max))),

    #' @field step
    #' Minimum step to increment the value
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x, error_call = quote(BoundedIntText$step))),

    #' @field continuous_update
    #' Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x, error_call = quote(BoundedIntText$continuous_update))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(BoundedIntText$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(BoundedIntText$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(BoundedIntText$disabled)))
  ),

  private = list(

  )
)

#' BoundedIntText widget
#'
#' @param value Int value
#' @param min Min value
#' @param max Max value
#' @param step Minimum step to increment the value
#' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#'
#' @param style Must inherit from [jupyter.widget.TextStyle].
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
BoundedIntText <- function(
  value = 0L,
  min = 0L,
  max = 100L,
  step = 1L,
  continuous_update = FALSE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  style = TextStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.BoundedIntText$new(
    value = value,
    min = min,
    max = max,
    step = step,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    style = style,
    ...,
    error_call = error_call
  )
}


#' BoundedFloatText widget
#'
#' @export
jupyter.widget.BoundedFloatText <- R6::R6Class("jupyter.widget.BoundedFloatText", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value Float value
    #' @param min Min value
    #' @param max Max value
    #' @param step Minimum step to increment the value
    #' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param style Must inherit from [jupyter.widget.TextStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.BoundedFloatText' widget
    initialize = function(
      value = 0,
      min = 0,
      max = 100,
      step = NULL,
      continuous_update = FALSE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      style = TextStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        min = self$check_state('min', min, error_call = error_call),
        max = self$check_state('max', max, error_call = error_call),
        step = self$check_state('step', step, error_call = error_call),
        continuous_update = self$check_state('continuous_update', continuous_update, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "BoundedFloatTextModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "FloatTextView",
        style = style,
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' Float value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(BoundedFloatText$value))),

    #' @field min
    #' Min value
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x, error_call = quote(BoundedFloatText$min))),

    #' @field max
    #' Max value
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x, error_call = quote(BoundedFloatText$max))),

    #' @field step
    #' Minimum step to increment the value
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x, error_call = quote(BoundedFloatText$step))),

    #' @field continuous_update
    #' Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x, error_call = quote(BoundedFloatText$continuous_update))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(BoundedFloatText$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(BoundedFloatText$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(BoundedFloatText$disabled)))
  ),

  private = list(

  )
)

#' BoundedFloatText widget
#'
#' @param value Float value
#' @param min Min value
#' @param max Max value
#' @param step Minimum step to increment the value
#' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#'
#' @param style Must inherit from [jupyter.widget.TextStyle].
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
BoundedFloatText <- function(
  value = 0,
  min = 0,
  max = 100,
  step = NULL,
  continuous_update = FALSE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  style = TextStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.BoundedFloatText$new(
    value = value,
    min = min,
    max = max,
    step = step,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    style = style,
    ...,
    error_call = error_call
  )
}


#' HTML widget
#'
#' @export
jupyter.widget.HTML <- R6::R6Class("jupyter.widget.HTML", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value String value
    #' @param placeholder Placeholder text to display when nothing has been typed
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param style Must inherit from [jupyter.widget.HTMLStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.HTML' widget
    initialize = function(
      value = "",
      placeholder = "\U{200B}",
      description = "",
      description_allow_html = FALSE,
      style = HTMLStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        placeholder = self$check_state('placeholder', placeholder, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "HTMLModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "HTMLView",
        style = style,
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' String value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(HTML$value))),

    #' @field placeholder
    #' Placeholder text to display when nothing has been typed
    placeholder = function(x) if(missing(x)) private$state_[['placeholder']] else self$update(placeholder = self$check_state('placeholder', x, error_call = quote(HTML$placeholder))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(HTML$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(HTML$description_allow_html)))
  ),

  private = list(

  )
)

#' HTML widget
#'
#' @param value String value
#' @param placeholder Placeholder text to display when nothing has been typed
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#'
#' @param style Must inherit from [jupyter.widget.HTMLStyle].
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
HTML <- function(
  value = "",
  placeholder = "\U{200B}",
  description = "",
  description_allow_html = FALSE,
  style = HTMLStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.HTML$new(
    value = value,
    placeholder = placeholder,
    description = description,
    description_allow_html = description_allow_html,
    style = style,
    ...,
    error_call = error_call
  )
}


#' HTMLMath widget
#'
#' @export
jupyter.widget.HTMLMath <- R6::R6Class("jupyter.widget.HTMLMath", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value String value
    #' @param placeholder Placeholder text to display when nothing has been typed
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param style Must inherit from [jupyter.widget.HTMLMathStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.HTMLMath' widget
    initialize = function(
      value = "",
      placeholder = "\U{200B}",
      description = "",
      description_allow_html = FALSE,
      style = HTMLMathStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        placeholder = self$check_state('placeholder', placeholder, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "HTMLMathModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "HTMLMathView",
        style = style,
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' String value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(HTMLMath$value))),

    #' @field placeholder
    #' Placeholder text to display when nothing has been typed
    placeholder = function(x) if(missing(x)) private$state_[['placeholder']] else self$update(placeholder = self$check_state('placeholder', x, error_call = quote(HTMLMath$placeholder))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(HTMLMath$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(HTMLMath$description_allow_html)))
  ),

  private = list(

  )
)

#' HTMLMath widget
#'
#' @param value String value
#' @param placeholder Placeholder text to display when nothing has been typed
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#'
#' @param style Must inherit from [jupyter.widget.HTMLMathStyle].
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
HTMLMath <- function(
  value = "",
  placeholder = "\U{200B}",
  description = "",
  description_allow_html = FALSE,
  style = HTMLMathStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.HTMLMath$new(
    value = value,
    placeholder = placeholder,
    description = description,
    description_allow_html = description_allow_html,
    style = style,
    ...,
    error_call = error_call
  )
}


#' ToggleButton widget
#'
#' @export
jupyter.widget.ToggleButton <- R6::R6Class("jupyter.widget.ToggleButton", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value Bool value
    #' @param button_style Use a predefined styling for the button.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes.
    #' @param icon Font-awesome icon.
    #' @param style Must inherit from [jupyter.widget.ToggleButtonStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.ToggleButton' widget
    initialize = function(
      value = FALSE,
      button_style = "",
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      icon = "",
      style = ToggleButtonStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        button_style = self$check_state('button_style', button_style, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call),
        icon = self$check_state('icon', icon, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "ToggleButtonModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "ToggleButtonView",
        style = style,
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' Bool value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(ToggleButton$value))),

    #' @field button_style
    #' Use a predefined styling for the button.
    button_style = function(x) if(missing(x)) private$state_[['button_style']] else self$update(button_style = self$check_state('button_style', x, error_call = quote(ToggleButton$button_style))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(ToggleButton$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(ToggleButton$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes.
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(ToggleButton$disabled))),

    #' @field icon
    #' Font-awesome icon.
    icon = function(x) if(missing(x)) private$state_[['icon']] else self$update(icon = self$check_state('icon', x, error_call = quote(ToggleButton$icon)))
  ),

  private = list(

  )
)

#' ToggleButton widget
#'
#' @param value Bool value
#' @param button_style Use a predefined styling for the button.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes.
#' @param icon Font-awesome icon.
#'
#' @param style Must inherit from [jupyter.widget.ToggleButtonStyle].
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
ToggleButton <- function(
  value = FALSE,
  button_style = "",
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  icon = "",
  style = ToggleButtonStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.ToggleButton$new(
    value = value,
    button_style = button_style,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    icon = icon,
    style = style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.ToggleButton", "button_style", unbox_one_of(c("primary", "success", "info", "warning", "danger"), allow_null = TRUE, allow_empty = TRUE))
})

#' Label widget
#'
#' @export
jupyter.widget.Label <- R6::R6Class("jupyter.widget.Label", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value String value
    #' @param placeholder Placeholder text to display when nothing has been typed
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param style Must inherit from [jupyter.widget.LabelStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Label' widget
    initialize = function(
      value = "",
      placeholder = "\U{200B}",
      description = "",
      description_allow_html = FALSE,
      style = LabelStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        placeholder = self$check_state('placeholder', placeholder, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "LabelModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "LabelView",
        style = style,
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' String value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(Label$value))),

    #' @field placeholder
    #' Placeholder text to display when nothing has been typed
    placeholder = function(x) if(missing(x)) private$state_[['placeholder']] else self$update(placeholder = self$check_state('placeholder', x, error_call = quote(Label$placeholder))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(Label$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(Label$description_allow_html)))
  ),

  private = list(

  )
)

#' Label widget
#'
#' @param value String value
#' @param placeholder Placeholder text to display when nothing has been typed
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#'
#' @param style Must inherit from [jupyter.widget.LabelStyle].
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Label <- function(
  value = "",
  placeholder = "\U{200B}",
  description = "",
  description_allow_html = FALSE,
  style = LabelStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.Label$new(
    value = value,
    placeholder = placeholder,
    description = description,
    description_allow_html = description_allow_html,
    style = style,
    ...,
    error_call = error_call
  )
}


#' IntProgress widget
#'
#' @export
jupyter.widget.IntProgress <- R6::R6Class("jupyter.widget.IntProgress", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value Int value
    #' @param min Min value
    #' @param max Max value
    #' @param bar_style Use a predefined styling for the progress bar.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param orientation Vertical or horizontal.
    #' @param style Must inherit from [jupyter.widget.ProgressStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.IntProgress' widget
    initialize = function(
      value = 0L,
      min = 0L,
      max = 100L,
      bar_style = "",
      description = "",
      description_allow_html = FALSE,
      orientation = "horizontal",
      style = ProgressStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        min = self$check_state('min', min, error_call = error_call),
        max = self$check_state('max', max, error_call = error_call),
        bar_style = self$check_state('bar_style', bar_style, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        orientation = self$check_state('orientation', orientation, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "IntProgressModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "ProgressView",
        style = style,
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' Int value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(IntProgress$value))),

    #' @field min
    #' Min value
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x, error_call = quote(IntProgress$min))),

    #' @field max
    #' Max value
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x, error_call = quote(IntProgress$max))),

    #' @field bar_style
    #' Use a predefined styling for the progress bar.
    bar_style = function(x) if(missing(x)) private$state_[['bar_style']] else self$update(bar_style = self$check_state('bar_style', x, error_call = quote(IntProgress$bar_style))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(IntProgress$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(IntProgress$description_allow_html))),

    #' @field orientation
    #' Vertical or horizontal.
    orientation = function(x) if(missing(x)) private$state_[['orientation']] else self$update(orientation = self$check_state('orientation', x, error_call = quote(IntProgress$orientation)))
  ),

  private = list(

  )
)

#' IntProgress widget
#'
#' @param value Int value
#' @param min Min value
#' @param max Max value
#' @param bar_style Use a predefined styling for the progress bar.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param orientation Vertical or horizontal.
#'
#' @param style Must inherit from [jupyter.widget.ProgressStyle].
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
IntProgress <- function(
  value = 0L,
  min = 0L,
  max = 100L,
  bar_style = "",
  description = "",
  description_allow_html = FALSE,
  orientation = "horizontal",
  style = ProgressStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.IntProgress$new(
    value = value,
    min = min,
    max = max,
    bar_style = bar_style,
    description = description,
    description_allow_html = description_allow_html,
    orientation = orientation,
    style = style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.IntProgress", "bar_style", unbox_one_of(c("success", "info", "warning", "danger"), allow_null = FALSE, allow_empty = TRUE))
  set_widget_state_check("jupyter.widget.IntProgress", "orientation", unbox_one_of(c("horizontal", "vertical"), allow_null = FALSE, allow_empty = FALSE))
})

#' FloatProgress widget
#'
#' @export
jupyter.widget.FloatProgress <- R6::R6Class("jupyter.widget.FloatProgress", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value Float value
    #' @param min Min value
    #' @param max Max value
    #' @param bar_style Use a predefined styling for the progress bar.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param orientation Vertical or horizontal.
    #' @param style Must inherit from [jupyter.widget.ProgressStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.FloatProgress' widget
    initialize = function(
      value = 0,
      min = 0,
      max = 100,
      bar_style = "",
      description = "",
      description_allow_html = FALSE,
      orientation = "horizontal",
      style = ProgressStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        min = self$check_state('min', min, error_call = error_call),
        max = self$check_state('max', max, error_call = error_call),
        bar_style = self$check_state('bar_style', bar_style, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        orientation = self$check_state('orientation', orientation, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "FloatProgressModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "ProgressView",
        style = style,
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' Float value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(FloatProgress$value))),

    #' @field min
    #' Min value
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x, error_call = quote(FloatProgress$min))),

    #' @field max
    #' Max value
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x, error_call = quote(FloatProgress$max))),

    #' @field bar_style
    #' Use a predefined styling for the progress bar.
    bar_style = function(x) if(missing(x)) private$state_[['bar_style']] else self$update(bar_style = self$check_state('bar_style', x, error_call = quote(FloatProgress$bar_style))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(FloatProgress$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(FloatProgress$description_allow_html))),

    #' @field orientation
    #' Vertical or horizontal.
    orientation = function(x) if(missing(x)) private$state_[['orientation']] else self$update(orientation = self$check_state('orientation', x, error_call = quote(FloatProgress$orientation)))
  ),

  private = list(

  )
)

#' FloatProgress widget
#'
#' @param value Float value
#' @param min Min value
#' @param max Max value
#' @param bar_style Use a predefined styling for the progress bar.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param orientation Vertical or horizontal.
#'
#' @param style Must inherit from [jupyter.widget.ProgressStyle].
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
FloatProgress <- function(
  value = 0,
  min = 0,
  max = 100,
  bar_style = "",
  description = "",
  description_allow_html = FALSE,
  orientation = "horizontal",
  style = ProgressStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.FloatProgress$new(
    value = value,
    min = min,
    max = max,
    bar_style = bar_style,
    description = description,
    description_allow_html = description_allow_html,
    orientation = orientation,
    style = style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.FloatProgress", "bar_style", unbox_one_of(c("success", "info", "warning", "danger"), allow_null = FALSE, allow_empty = TRUE))
  set_widget_state_check("jupyter.widget.FloatProgress", "orientation", unbox_one_of(c("horizontal", "vertical"), allow_null = FALSE, allow_empty = FALSE))
})

#' Password widget
#'
#' @export
jupyter.widget.Password <- R6::R6Class("jupyter.widget.Password", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value String value
    #' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param placeholder Placeholder text to display when nothing has been typed
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Password' widget
    initialize = function(
      value = "",
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      placeholder = "\U{200B}",

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        continuous_update = self$check_state('continuous_update', continuous_update, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call),
        placeholder = self$check_state('placeholder', placeholder, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "PasswordModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "PasswordView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' String value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(Password$value))),

    #' @field continuous_update
    #' Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x, error_call = quote(Password$continuous_update))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(Password$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(Password$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(Password$disabled))),

    #' @field placeholder
    #' Placeholder text to display when nothing has been typed
    placeholder = function(x) if(missing(x)) private$state_[['placeholder']] else self$update(placeholder = self$check_state('placeholder', x, error_call = quote(Password$placeholder)))
  ),

  private = list(

  )
)

#' Password widget
#'
#' @param value String value
#' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param placeholder Placeholder text to display when nothing has been typed
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Password <- function(
  value = "",
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  placeholder = "\U{200B}",
  ...,
  error_call = current_env()
){
  jupyter.widget.Password$new(
    value = value,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    placeholder = placeholder,
    ...,
    error_call = error_call
  )
}


#' Box widget
#'
#' @export
jupyter.widget.Box <- R6::R6Class("jupyter.widget.Box", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param children List of widget children
    #' @param box_style Use a predefined styling for the box.
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Box' widget
    initialize = function(
      children = list(),
      box_style = "",

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        children = self$check_state('children', children, error_call = error_call),
        box_style = self$check_state('box_style', box_style, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "BoxModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "BoxView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field children
    #' List of widget children
    children = function(x) if(missing(x)) private$state_[['children']] else self$update(children = self$check_state('children', x, error_call = quote(Box$children))),

    #' @field box_style
    #' Use a predefined styling for the box.
    box_style = function(x) if(missing(x)) private$state_[['box_style']] else self$update(box_style = self$check_state('box_style', x, error_call = quote(Box$box_style)))
  ),

  private = list(
    children_ = list()
  )
)

#' Box widget
#'
#' @param children List of widget children
#' @param box_style Use a predefined styling for the box.
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Box <- function(
  children = list(),
  box_style = "",
  ...,
  error_call = current_env()
){
  jupyter.widget.Box$new(
    children = children,
    box_style = box_style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.Box", "children", check_state_children)
  set_widget_state_check("jupyter.widget.Box", "box_style", unbox_one_of(c("success", "info", "warning", "danger"), allow_null = TRUE, allow_empty = TRUE))
})

#' HBox widget
#'
#' @export
jupyter.widget.HBox <- R6::R6Class("jupyter.widget.HBox", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param children List of widget children
    #' @param box_style Use a predefined styling for the box.
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.HBox' widget
    initialize = function(
      children = list(),
      box_style = "",

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        children = self$check_state('children', children, error_call = error_call),
        box_style = self$check_state('box_style', box_style, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "HBoxModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "HBoxView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field children
    #' List of widget children
    children = function(x) if(missing(x)) private$state_[['children']] else self$update(children = self$check_state('children', x, error_call = quote(HBox$children))),

    #' @field box_style
    #' Use a predefined styling for the box.
    box_style = function(x) if(missing(x)) private$state_[['box_style']] else self$update(box_style = self$check_state('box_style', x, error_call = quote(HBox$box_style)))
  ),

  private = list(
    children_ = list()
  )
)

#' HBox widget
#'
#' @param children List of widget children
#' @param box_style Use a predefined styling for the box.
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
HBox <- function(
  children = list(),
  box_style = "",
  ...,
  error_call = current_env()
){
  jupyter.widget.HBox$new(
    children = children,
    box_style = box_style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.HBox", "children", check_state_children)
  set_widget_state_check("jupyter.widget.HBox", "box_style", unbox_one_of(c("success", "info", "warning", "danger"), allow_null = TRUE, allow_empty = TRUE))
})

#' VBox widget
#'
#' @export
jupyter.widget.VBox <- R6::R6Class("jupyter.widget.VBox", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param children List of widget children
    #' @param box_style Use a predefined styling for the box.
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.VBox' widget
    initialize = function(
      children = list(),
      box_style = "",

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        children = self$check_state('children', children, error_call = error_call),
        box_style = self$check_state('box_style', box_style, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "VBoxModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "VBoxView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field children
    #' List of widget children
    children = function(x) if(missing(x)) private$state_[['children']] else self$update(children = self$check_state('children', x, error_call = quote(VBox$children))),

    #' @field box_style
    #' Use a predefined styling for the box.
    box_style = function(x) if(missing(x)) private$state_[['box_style']] else self$update(box_style = self$check_state('box_style', x, error_call = quote(VBox$box_style)))
  ),

  private = list(
    children_ = list()
  )
)

#' VBox widget
#'
#' @param children List of widget children
#' @param box_style Use a predefined styling for the box.
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
VBox <- function(
  children = list(),
  box_style = "",
  ...,
  error_call = current_env()
){
  jupyter.widget.VBox$new(
    children = children,
    box_style = box_style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.VBox", "children", check_state_children)
  set_widget_state_check("jupyter.widget.VBox", "box_style", unbox_one_of(c("success", "info", "warning", "danger"), allow_null = TRUE, allow_empty = TRUE))
})

#' GridBox widget
#'
#' @export
jupyter.widget.GridBox <- R6::R6Class("jupyter.widget.GridBox", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param children List of widget children
    #' @param box_style Use a predefined styling for the box.
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.GridBox' widget
    initialize = function(
      children = list(),
      box_style = "",

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        children = self$check_state('children', children, error_call = error_call),
        box_style = self$check_state('box_style', box_style, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "GridBoxModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "GridBoxView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field children
    #' List of widget children
    children = function(x) if(missing(x)) private$state_[['children']] else self$update(children = self$check_state('children', x, error_call = quote(GridBox$children))),

    #' @field box_style
    #' Use a predefined styling for the box.
    box_style = function(x) if(missing(x)) private$state_[['box_style']] else self$update(box_style = self$check_state('box_style', x, error_call = quote(GridBox$box_style)))
  ),

  private = list(
    children_ = list()
  )
)

#' GridBox widget
#'
#' @param children List of widget children
#' @param box_style Use a predefined styling for the box.
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
GridBox <- function(
  children = list(),
  box_style = "",
  ...,
  error_call = current_env()
){
  jupyter.widget.GridBox$new(
    children = children,
    box_style = box_style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.GridBox", "children", check_state_children)
  set_widget_state_check("jupyter.widget.GridBox", "box_style", unbox_one_of(c("success", "info", "warning", "danger"), allow_null = TRUE, allow_empty = TRUE))
})

#' Tab widget
#'
#' @export
jupyter.widget.Tab <- R6::R6Class("jupyter.widget.Tab", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param children List of widget children
    #' @param box_style Use a predefined styling for the box.
    #' @param selected_index The index of the selected page. This is either an integer selecting a particular sub-widget, or None to have no widgets selected.
    #' @param titles Titles of the pages
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Tab' widget
    initialize = function(
      children = list(),
      box_style = "",
      selected_index = NULL,
      titles = list(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        children = self$check_state('children', children, error_call = error_call),
        box_style = self$check_state('box_style', box_style, error_call = error_call),
        selected_index = self$check_state('selected_index', selected_index, error_call = error_call),
        titles = self$check_state('titles', titles, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "TabModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "TabView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field children
    #' List of widget children
    children = function(x) if(missing(x)) private$state_[['children']] else self$update(children = self$check_state('children', x, error_call = quote(Tab$children))),

    #' @field box_style
    #' Use a predefined styling for the box.
    box_style = function(x) if(missing(x)) private$state_[['box_style']] else self$update(box_style = self$check_state('box_style', x, error_call = quote(Tab$box_style))),

    #' @field selected_index
    #' The index of the selected page. This is either an integer selecting a particular sub-widget, or None to have no widgets selected.
    selected_index = function(x) if(missing(x)) private$state_[['selected_index']] else self$update(selected_index = self$check_state('selected_index', x, error_call = quote(Tab$selected_index))),

    #' @field titles
    #' Titles of the pages
    titles = function(x) if(missing(x)) private$state_[['titles']] else self$update(titles = self$check_state('titles', x, error_call = quote(Tab$titles)))
  ),

  private = list(
    children_ = list()
  )
)

#' Tab widget
#'
#' @param children List of widget children
#' @param box_style Use a predefined styling for the box.
#' @param selected_index The index of the selected page. This is either an integer selecting a particular sub-widget, or None to have no widgets selected.
#' @param titles Titles of the pages
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Tab <- function(
  children = list(),
  box_style = "",
  selected_index = NULL,
  titles = list(),
  ...,
  error_call = current_env()
){
  jupyter.widget.Tab$new(
    children = children,
    box_style = box_style,
    selected_index = selected_index,
    titles = titles,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.Tab", "children", check_state_children)
  set_widget_state_check("jupyter.widget.Tab", "box_style", unbox_one_of(c("success", "info", "warning", "danger"), allow_null = TRUE, allow_empty = TRUE))
})

#' Stack widget
#'
#' @export
jupyter.widget.Stack <- R6::R6Class("jupyter.widget.Stack", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param children List of widget children
    #' @param box_style Use a predefined styling for the box.
    #' @param selected_index The index of the selected page. This is either an integer selecting a particular sub-widget, or None to have no widgets selected.
    #' @param titles Titles of the pages
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Stack' widget
    initialize = function(
      children = list(),
      box_style = "",
      selected_index = NULL,
      titles = list(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        children = self$check_state('children', children, error_call = error_call),
        box_style = self$check_state('box_style', box_style, error_call = error_call),
        selected_index = self$check_state('selected_index', selected_index, error_call = error_call),
        titles = self$check_state('titles', titles, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "StackModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "StackView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field children
    #' List of widget children
    children = function(x) if(missing(x)) private$state_[['children']] else self$update(children = self$check_state('children', x, error_call = quote(Stack$children))),

    #' @field box_style
    #' Use a predefined styling for the box.
    box_style = function(x) if(missing(x)) private$state_[['box_style']] else self$update(box_style = self$check_state('box_style', x, error_call = quote(Stack$box_style))),

    #' @field selected_index
    #' The index of the selected page. This is either an integer selecting a particular sub-widget, or None to have no widgets selected.
    selected_index = function(x) if(missing(x)) private$state_[['selected_index']] else self$update(selected_index = self$check_state('selected_index', x, error_call = quote(Stack$selected_index))),

    #' @field titles
    #' Titles of the pages
    titles = function(x) if(missing(x)) private$state_[['titles']] else self$update(titles = self$check_state('titles', x, error_call = quote(Stack$titles)))
  ),

  private = list(
    children_ = list()
  )
)

#' Stack widget
#'
#' @param children List of widget children
#' @param box_style Use a predefined styling for the box.
#' @param selected_index The index of the selected page. This is either an integer selecting a particular sub-widget, or None to have no widgets selected.
#' @param titles Titles of the pages
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Stack <- function(
  children = list(),
  box_style = "",
  selected_index = NULL,
  titles = list(),
  ...,
  error_call = current_env()
){
  jupyter.widget.Stack$new(
    children = children,
    box_style = box_style,
    selected_index = selected_index,
    titles = titles,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.Stack", "children", check_state_children)
  set_widget_state_check("jupyter.widget.Stack", "box_style", unbox_one_of(c("success", "info", "warning", "danger"), allow_null = TRUE, allow_empty = TRUE))
})

#' Button widget
#'
#' @export
jupyter.widget.Button <- R6::R6Class("jupyter.widget.Button", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param description Button label.
    #' @param button_style Use a predefined styling for the button.
    #' @param disabled Enable or disable user changes.
    #' @param icon Font-awesome icon names, without the 'fa-' prefix.
    #' @param style Must inherit from [jupyter.widget.ButtonStyle].
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Button' widget
    initialize = function(
      description = "",
      button_style = "",
      disabled = FALSE,
      icon = "",
      style = ButtonStyle(),

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        description = self$check_state('description', description, error_call = error_call),
        button_style = self$check_state('button_style', button_style, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call),
        icon = self$check_state('icon', icon, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "ButtonModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "ButtonView",
        style = style,
        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field description
    #' Button label.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(Button$description))),

    #' @field button_style
    #' Use a predefined styling for the button.
    button_style = function(x) if(missing(x)) private$state_[['button_style']] else self$update(button_style = self$check_state('button_style', x, error_call = quote(Button$button_style))),

    #' @field disabled
    #' Enable or disable user changes.
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(Button$disabled))),

    #' @field icon
    #' Font-awesome icon names, without the 'fa-' prefix.
    icon = function(x) if(missing(x)) private$state_[['icon']] else self$update(icon = self$check_state('icon', x, error_call = quote(Button$icon)))
  ),

  private = list(

  )
)

#' Button widget
#'
#' @param description Button label.
#' @param button_style Use a predefined styling for the button.
#' @param disabled Enable or disable user changes.
#' @param icon Font-awesome icon names, without the 'fa-' prefix.
#'
#' @param style Must inherit from [jupyter.widget.ButtonStyle].
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Button <- function(
  description = "",
  button_style = "",
  disabled = FALSE,
  icon = "",
  style = ButtonStyle(),
  ...,
  error_call = current_env()
){
  jupyter.widget.Button$new(
    description = description,
    button_style = button_style,
    disabled = disabled,
    icon = icon,
    style = style,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.Button", "button_style", unbox_one_of(c("primary", "success", "info", "warning", "danger"), allow_null = TRUE, allow_empty = TRUE))
})

#' Textarea widget
#'
#' @export
jupyter.widget.Textarea <- R6::R6Class("jupyter.widget.Textarea", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value String value
    #' @param rows The number of rows to display.
    #' @param placeholder Placeholder text to display when nothing has been typed
    #' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Textarea' widget
    initialize = function(
      value = "",
      rows = NULL,
      placeholder = "\U{200B}",
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        rows = self$check_state('rows', rows, error_call = error_call),
        placeholder = self$check_state('placeholder', placeholder, error_call = error_call),
        continuous_update = self$check_state('continuous_update', continuous_update, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "TextareaModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "TextareaView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #' String value
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(Textarea$value))),

    #' @field rows
    #' The number of rows to display.
    rows = function(x) if(missing(x)) private$state_[['rows']] else self$update(rows = self$check_state('rows', x, error_call = quote(Textarea$rows))),

    #' @field placeholder
    #' Placeholder text to display when nothing has been typed
    placeholder = function(x) if(missing(x)) private$state_[['placeholder']] else self$update(placeholder = self$check_state('placeholder', x, error_call = quote(Textarea$placeholder))),

    #' @field continuous_update
    #' Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x, error_call = quote(Textarea$continuous_update))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(Textarea$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(Textarea$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(Textarea$disabled)))
  ),

  private = list(

  )
)

#' Textarea widget
#'
#' @param value String value
#' @param rows The number of rows to display.
#' @param placeholder Placeholder text to display when nothing has been typed
#' @param continuous_update Update the value as the user types. If False, update on submission, e.g., pressing Enter or navigating away.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Textarea <- function(
  value = "",
  rows = NULL,
  placeholder = "\U{200B}",
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  ...,
  error_call = current_env()
){
  jupyter.widget.Textarea$new(
    value = value,
    rows = rows,
    placeholder = placeholder,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    ...,
    error_call = error_call
  )
}


#' Time widget
#'
#' @export
jupyter.widget.Time <- R6::R6Class("jupyter.widget.Time", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param value (undocumented)
    #' @param min (undocumented)
    #' @param max (undocumented)
    #' @param step The time step to use for the picker, in seconds, or "any".
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes.
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Time' widget
    initialize = function(
      value = NULL,
      min = NULL,
      max = NULL,
      step = 60L,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        value = self$check_state('value', value, error_call = error_call),
        min = self$check_state('min', min, error_call = error_call),
        max = self$check_state('max', max, error_call = error_call),
        step = self$check_state('step', step, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "TimeModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "TimeView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field value
    #'
    value = function(x) if(missing(x)) private$state_[['value']] else self$update(value = self$check_state('value', x, error_call = quote(Time$value))),

    #' @field min
    #'
    min = function(x) if(missing(x)) private$state_[['min']] else self$update(min = self$check_state('min', x, error_call = quote(Time$min))),

    #' @field max
    #'
    max = function(x) if(missing(x)) private$state_[['max']] else self$update(max = self$check_state('max', x, error_call = quote(Time$max))),

    #' @field step
    #' The time step to use for the picker, in seconds, or "any".
    step = function(x) if(missing(x)) private$state_[['step']] else self$update(step = self$check_state('step', x, error_call = quote(Time$step))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(Time$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(Time$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes.
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(Time$disabled)))
  ),

  private = list(

  )
)

#' Time widget
#'
#' @param value (undocumented)
#' @param min (undocumented)
#' @param max (undocumented)
#' @param step The time step to use for the picker, in seconds, or "any".
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes.
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Time <- function(
  value = NULL,
  min = NULL,
  max = NULL,
  step = 60L,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  ...,
  error_call = current_env()
){
  jupyter.widget.Time$new(
    value = value,
    min = min,
    max = max,
    step = step,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    ...,
    error_call = error_call
  )
}


#' Select widget
#'
#' @export
jupyter.widget.Select <- R6::R6Class("jupyter.widget.Select", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param options The labels for the options.
    #' @param index Selected index
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param rows The number of rows to display.
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.Select' widget
    initialize = function(
      options = list(),
      index = NULL,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      rows = 5L,

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        `_options_labels` = self$check_state('options', options, error_call = error_call),
        index = self$check_state('index', index, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call),
        rows = self$check_state('rows', rows, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "SelectModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "SelectView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field options
    #' set options
    options = function(x) if (missing(x)) private$state_[['_options_labels']] else self$update(`_options_labels` = self$check_state('options', x, error_call = quote(Select$options))),

    #' @field index
    #' Selected index
    index = function(x) if(missing(x)) private$state_[['index']] else self$update(index = self$check_state('index', x, error_call = quote(Select$index))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(Select$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(Select$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(Select$disabled))),

    #' @field rows
    #' The number of rows to display.
    rows = function(x) if(missing(x)) private$state_[['rows']] else self$update(rows = self$check_state('rows', x, error_call = quote(Select$rows)))
  ),

  private = list(

  )
)

#' Select widget
#'
#' @param options The labels for the options.
#' @param index Selected index
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param rows The number of rows to display.
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
Select <- function(
  options = list(),
  index = NULL,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  rows = 5L,
  ...,
  error_call = current_env()
){
  jupyter.widget.Select$new(
    options = options,
    index = index,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    rows = rows,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.Select", "options", check_state_options)
})

#' SelectMultiple widget
#'
#' @export
jupyter.widget.SelectMultiple <- R6::R6Class("jupyter.widget.SelectMultiple", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param options The labels for the options.
    #' @param index Selected indices
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param rows The number of rows to display.
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.SelectMultiple' widget
    initialize = function(
      options = list(),
      index = list(),
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      rows = 5L,

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        `_options_labels` = self$check_state('options', options, error_call = error_call),
        index = self$check_state('index', index, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call),
        rows = self$check_state('rows', rows, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "SelectMultipleModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "SelectMultipleView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field options
    #' set options
    options = function(x) if (missing(x)) private$state_[['_options_labels']] else self$update(`_options_labels` = self$check_state('options', x, error_call = quote(SelectMultiple$options))),

    #' @field index
    #' Selected indices
    index = function(x) if(missing(x)) private$state_[['index']] else self$update(index = self$check_state('index', x, error_call = quote(SelectMultiple$index))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(SelectMultiple$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(SelectMultiple$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(SelectMultiple$disabled))),

    #' @field rows
    #' The number of rows to display.
    rows = function(x) if(missing(x)) private$state_[['rows']] else self$update(rows = self$check_state('rows', x, error_call = quote(SelectMultiple$rows)))
  ),

  private = list(

  )
)

#' SelectMultiple widget
#'
#' @param options The labels for the options.
#' @param index Selected indices
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param rows The number of rows to display.
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
SelectMultiple <- function(
  options = list(),
  index = list(),
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  rows = 5L,
  ...,
  error_call = current_env()
){
  jupyter.widget.SelectMultiple$new(
    options = options,
    index = index,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    rows = rows,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.SelectMultiple", "options", check_state_options)
})

#' SelectionSlider widget
#'
#' @export
jupyter.widget.SelectionSlider <- R6::R6Class("jupyter.widget.SelectionSlider", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param options The labels for the options.
    #' @param index Selected index
    #' @param behavior Slider dragging behavior.
    #' @param continuous_update Update the value of the widget as the user is holding the slider.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param orientation Vertical or horizontal.
    #' @param readout Display the current selected label next to the slider
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.SelectionSlider' widget
    initialize = function(
      options = list(),
      index = 0L,
      behavior = "drag-tap",
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      orientation = "horizontal",
      readout = TRUE,

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        `_options_labels` = self$check_state('options', options, error_call = error_call),
        index = self$check_state('index', index, error_call = error_call),
        behavior = self$check_state('behavior', behavior, error_call = error_call),
        continuous_update = self$check_state('continuous_update', continuous_update, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call),
        orientation = self$check_state('orientation', orientation, error_call = error_call),
        readout = self$check_state('readout', readout, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "SelectionSliderModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "SelectionSliderView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field options
    #' set options
    options = function(x) if (missing(x)) private$state_[['_options_labels']] else self$update(`_options_labels` = self$check_state('options', x, error_call = quote(SelectionSlider$options))),

    #' @field index
    #' Selected index
    index = function(x) if(missing(x)) private$state_[['index']] else self$update(index = self$check_state('index', x, error_call = quote(SelectionSlider$index))),

    #' @field behavior
    #' Slider dragging behavior.
    behavior = function(x) if(missing(x)) private$state_[['behavior']] else self$update(behavior = self$check_state('behavior', x, error_call = quote(SelectionSlider$behavior))),

    #' @field continuous_update
    #' Update the value of the widget as the user is holding the slider.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x, error_call = quote(SelectionSlider$continuous_update))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(SelectionSlider$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(SelectionSlider$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(SelectionSlider$disabled))),

    #' @field orientation
    #' Vertical or horizontal.
    orientation = function(x) if(missing(x)) private$state_[['orientation']] else self$update(orientation = self$check_state('orientation', x, error_call = quote(SelectionSlider$orientation))),

    #' @field readout
    #' Display the current selected label next to the slider
    readout = function(x) if(missing(x)) private$state_[['readout']] else self$update(readout = self$check_state('readout', x, error_call = quote(SelectionSlider$readout)))
  ),

  private = list(

  )
)

#' SelectionSlider widget
#'
#' @param options The labels for the options.
#' @param index Selected index
#' @param behavior Slider dragging behavior.
#' @param continuous_update Update the value of the widget as the user is holding the slider.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param orientation Vertical or horizontal.
#' @param readout Display the current selected label next to the slider
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
SelectionSlider <- function(
  options = list(),
  index = 0L,
  behavior = "drag-tap",
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  orientation = "horizontal",
  readout = TRUE,
  ...,
  error_call = current_env()
){
  jupyter.widget.SelectionSlider$new(
    options = options,
    index = index,
    behavior = behavior,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    orientation = orientation,
    readout = readout,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.SelectionSlider", "options", check_state_options)
  set_widget_state_check("jupyter.widget.SelectionSlider", "behavior", unbox_one_of(c("drag-tap", "drag-snap", "tap", "drag", "snap"), allow_null = FALSE, allow_empty = FALSE))
  set_widget_state_check("jupyter.widget.SelectionSlider", "orientation", unbox_one_of(c("horizontal", "vertical"), allow_null = FALSE, allow_empty = FALSE))
})

#' SelectionRangeSlider widget
#'
#' @export
jupyter.widget.SelectionRangeSlider <- R6::R6Class("jupyter.widget.SelectionRangeSlider", inherit = jupyter.widget.DOMWidget,
  public = list(

    #' @param options The labels for the options.
    #' @param index Min and max selected indices
    #' @param behavior Slider dragging behavior.
    #' @param continuous_update Update the value of the widget as the user is holding the slider.
    #' @param description Description of the control.
    #' @param description_allow_html Accept HTML in the description.
    #' @param disabled Enable or disable user changes
    #' @param orientation Vertical or horizontal.
    #' @param readout Display the current selected label next to the slider
    #'
    #' @param ... See [jupyter.widgets.base::DOMWidget]
    #' @param error_call see [rlang::args_error_context()]
    #'
    #' @return a new 'jupyter.widget.SelectionRangeSlider' widget
    initialize = function(
      options = list(),
      index = list(0L, 0L),
      behavior = "drag-tap",
      continuous_update = TRUE,
      description = "",
      description_allow_html = FALSE,
      disabled = FALSE,
      orientation = "horizontal",
      readout = TRUE,

      ...,
      error_call = caller_env()
    )
    {
      private$state_ <- update_list(private$state_,
        `_options_labels` = self$check_state('options', options, error_call = error_call),
        index = self$check_state('index', index, error_call = error_call),
        behavior = self$check_state('behavior', behavior, error_call = error_call),
        continuous_update = self$check_state('continuous_update', continuous_update, error_call = error_call),
        description = self$check_state('description', description, error_call = error_call),
        description_allow_html = self$check_state('description_allow_html', description_allow_html, error_call = error_call),
        disabled = self$check_state('disabled', disabled, error_call = error_call),
        orientation = self$check_state('orientation', orientation, error_call = error_call),
        readout = self$check_state('readout', readout, error_call = error_call)
      )

      super$initialize(
        `_model_module` = "@jupyter-widgets/controls",
        `_model_name`   = "SelectionRangeSliderModel",
        `_view_module`  = "@jupyter-widgets/controls",
        `_view_name`    = "SelectionRangeSliderView",

        ...,
        error_call = error_call
      )

    }
  ),

  active = list(

    #' @field options
    #' set options
    options = function(x) if (missing(x)) private$state_[['_options_labels']] else self$update(`_options_labels` = self$check_state('options', x, error_call = quote(SelectionRangeSlider$options))),

    #' @field index
    #' Min and max selected indices
    index = function(x) if(missing(x)) private$state_[['index']] else self$update(index = self$check_state('index', x, error_call = quote(SelectionRangeSlider$index))),

    #' @field behavior
    #' Slider dragging behavior.
    behavior = function(x) if(missing(x)) private$state_[['behavior']] else self$update(behavior = self$check_state('behavior', x, error_call = quote(SelectionRangeSlider$behavior))),

    #' @field continuous_update
    #' Update the value of the widget as the user is holding the slider.
    continuous_update = function(x) if(missing(x)) private$state_[['continuous_update']] else self$update(continuous_update = self$check_state('continuous_update', x, error_call = quote(SelectionRangeSlider$continuous_update))),

    #' @field description
    #' Description of the control.
    description = function(x) if(missing(x)) private$state_[['description']] else self$update(description = self$check_state('description', x, error_call = quote(SelectionRangeSlider$description))),

    #' @field description_allow_html
    #' Accept HTML in the description.
    description_allow_html = function(x) if(missing(x)) private$state_[['description_allow_html']] else self$update(description_allow_html = self$check_state('description_allow_html', x, error_call = quote(SelectionRangeSlider$description_allow_html))),

    #' @field disabled
    #' Enable or disable user changes
    disabled = function(x) if(missing(x)) private$state_[['disabled']] else self$update(disabled = self$check_state('disabled', x, error_call = quote(SelectionRangeSlider$disabled))),

    #' @field orientation
    #' Vertical or horizontal.
    orientation = function(x) if(missing(x)) private$state_[['orientation']] else self$update(orientation = self$check_state('orientation', x, error_call = quote(SelectionRangeSlider$orientation))),

    #' @field readout
    #' Display the current selected label next to the slider
    readout = function(x) if(missing(x)) private$state_[['readout']] else self$update(readout = self$check_state('readout', x, error_call = quote(SelectionRangeSlider$readout)))
  ),

  private = list(

  )
)

#' SelectionRangeSlider widget
#'
#' @param options The labels for the options.
#' @param index Min and max selected indices
#' @param behavior Slider dragging behavior.
#' @param continuous_update Update the value of the widget as the user is holding the slider.
#' @param description Description of the control.
#' @param description_allow_html Accept HTML in the description.
#' @param disabled Enable or disable user changes
#' @param orientation Vertical or horizontal.
#' @param readout Display the current selected label next to the slider
#'
#'
#' @param ... forwarded to [jupyter.widgets.base::jupyter.widget.DOMWidget] constructor
#' @inheritParams rlang::args_error_context
#'
#' @export
SelectionRangeSlider <- function(
  options = list(),
  index = list(0L, 0L),
  behavior = "drag-tap",
  continuous_update = TRUE,
  description = "",
  description_allow_html = FALSE,
  disabled = FALSE,
  orientation = "horizontal",
  readout = TRUE,
  ...,
  error_call = current_env()
){
  jupyter.widget.SelectionRangeSlider$new(
    options = options,
    index = index,
    behavior = behavior,
    continuous_update = continuous_update,
    description = description,
    description_allow_html = description_allow_html,
    disabled = disabled,
    orientation = orientation,
    readout = readout,
    ...,
    error_call = error_call
  )
}

rlang::on_load({
  set_widget_state_check("jupyter.widget.SelectionRangeSlider", "options", check_state_options)
  set_widget_state_check("jupyter.widget.SelectionRangeSlider", "behavior", unbox_one_of(c("drag-tap", "drag-snap", "tap", "drag", "snap"), allow_null = FALSE, allow_empty = FALSE))
  set_widget_state_check("jupyter.widget.SelectionRangeSlider", "orientation", unbox_one_of(c("horizontal", "vertical"), allow_null = FALSE, allow_empty = FALSE))
})

